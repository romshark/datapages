// Generated by github.com/romshark/datapages. DO NOT EDIT.

// Package href provides generators for datastar anchor hypertext references.
// These references must be used in the templates.
package href

import (
	"strconv"
	"strings"
)

// Index references /
func Index() string { return "/" }

// Settings references /settings/
func Settings() string {
	return "/settings/"
}

// Login references /login/
func Login() string {
	return "/login/"
}

// Messages references /messages/?chat
func Messages(query QueryMessages) string {
	var b strings.Builder
	l := len("/messages/")
	if query.Chat != "" {
		l += len("?")
	}
	if query.Chat != "" {
		l += len("chat=") + len(query.Chat)
	}
	b.Grow(l)

	b.WriteString("/messages/")
	if query.Chat != "" {
		b.WriteString("?")
	}
	if query.Chat != "" {
		b.WriteString("chat=")
		b.WriteString(query.Chat)
	}
	return b.String()
}

type QueryMessages struct {
	Chat string `query:"chat"`
}

// Search references /search/
func Search(query QuerySearch) string {
	var (
		pminStr string
		pmaxStr string
	)

	if query.PriceMin != 0 {
		pminStr = strconv.FormatInt(query.PriceMin, 10)
	}
	if query.PriceMax != 0 {
		pmaxStr = strconv.FormatInt(query.PriceMax, 10)
	}

	any := query.Term != "" ||
		query.Category != "" ||
		query.PriceMin != 0 ||
		query.PriceMax != 0 ||
		query.Location != ""

	var b strings.Builder
	l := len("/search/")
	if any {
		l += len("?")
	}

	// n = number of query params already accounted for (for '&')
	n := 0

	if query.Term != "" {
		if n > 0 {
			l += len("&")
		}
		n++
		l += len("t=") + len(query.Term)
	}
	if query.Category != "" {
		if n > 0 {
			l += len("&")
		}
		n++
		l += len("c=") + len(query.Category)
	}
	if query.PriceMin != 0 {
		if n > 0 {
			l += len("&")
		}
		n++
		l += len("pmin=") + len(pminStr)
	}
	if query.PriceMax != 0 {
		if n > 0 {
			l += len("&")
		}
		n++
		l += len("pmax=") + len(pmaxStr)
	}
	if query.Location != "" {
		if n > 0 {
			l += len("&")
		}
		n++
		l += len("l=") + len(query.Location)
	}
	_ = n

	b.Grow(l)

	b.WriteString("/search/")
	if any {
		b.WriteString("?")
	}

	n = 0

	if query.Term != "" {
		if n > 0 {
			b.WriteString("&")
		}
		n++
		b.WriteString("t=")
		b.WriteString(query.Term)
	}
	if query.Category != "" {
		if n > 0 {
			b.WriteString("&")
		}
		n++
		b.WriteString("c=")
		b.WriteString(query.Category)
	}
	if query.PriceMin != 0 {
		if n > 0 {
			b.WriteString("&")
		}
		n++
		b.WriteString("pmin=")
		b.WriteString(pminStr)
	}
	if query.PriceMax != 0 {
		if n > 0 {
			b.WriteString("&")
		}
		n++
		b.WriteString("pmax=")
		b.WriteString(pmaxStr)
	}
	if query.Location != "" {
		if n > 0 {
			b.WriteString("&")
		}
		b.WriteString("l=")
		b.WriteString(query.Location)
	}

	return b.String()
}

// QuerySearch is the query parameters for Search
type QuerySearch struct {
	Term     string `query:"t"`
	Category string `query:"c"`
	PriceMin int64  `query:"pmin"`
	PriceMax int64  `query:"pmax"`
	Location string `query:"l"`
}

// Post references /post/{slug}/
func Post(slug string) string {
	var b strings.Builder
	b.Grow(
		len("/post/") +
			len(slug) +
			len("/"),
	)
	b.WriteString("/post/")
	b.WriteString(slug)
	b.WriteString("/")
	return b.String()
}

// User references /user/{name}/
func User(name string) string {
	var b strings.Builder
	b.Grow(
		len("/user/") +
			len(name) +
			len("/"),
	)
	b.WriteString("/user/")
	b.WriteString(name)
	b.WriteString("/")
	return b.String()
}
