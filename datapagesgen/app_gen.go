// Generated by github.com/romshark/datapages. DO NOT EDIT.

package datapagesgen

import (
	"datapages/app"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/starfederation/datastar-go/datastar"
)

// --- Message Broker ---

const DefaultBodySizeLimit = 1024 * 1024 // 1 MiB

const (
	EvSubjMessagingSent           = "messaging.sent.*"
	EvSubjMessagingRead           = "messaging.read.*"
	EvSubjMessagingWriting        = "messaging.writing.*"
	EvSubjMessagingWritingStopped = "messaging.writing-stopped.*"
	EvSubjPostArchived            = "posts.archived"
)

const (
	EvSubjPrefMessagingSent           = "messaging.sent."
	EvSubjPrefMessagingRead           = "messaging.read."
	EvSubjPrefMessagingWriting        = "messaging.writing."
	EvSubjPrefMessagingWritingStopped = "messaging.writing-stopped."
)

func MessageBrokerStreamSubjects() []string {
	return []string{
		EvSubjMessagingSent,
		EvSubjMessagingRead,
		EvSubjMessagingWriting,
		EvSubjMessagingWritingStopped,
		EvSubjPostArchived,
	}
}

func evSubjPageIndex(userID string) []string {
	return []string{
		EvSubjPrefMessagingSent + userID,
		EvSubjPrefMessagingRead + userID,
	}
}

func evSubjPageMessages(userID string) []string {
	return []string{
		EvSubjPrefMessagingSent + userID,
		EvSubjPrefMessagingRead + userID,
		EvSubjPrefMessagingWriting + userID,
		EvSubjPrefMessagingWritingStopped + userID,
	}
}

func evSubjPagePost(userID string) []string {
	return []string{
		EvSubjPostArchived,
		EvSubjPrefMessagingSent + userID,
		EvSubjPrefMessagingRead + userID,
	}
}

func evSubjPageSearch(userID string) []string {
	return []string{
		EvSubjPrefMessagingSent + userID,
		EvSubjPrefMessagingRead + userID,
	}
}

func evSubjPageSettings(userID string) []string {
	return []string{
		EvSubjPrefMessagingSent + userID,
		EvSubjPrefMessagingRead + userID,
	}
}

// --- Auth: JWT ---

const DefaultAuthJWTCookieName = "sessjwt"

type AuthJWTConfig struct {
	Secret []byte

	Audience        string            // Optional; Not set by default.
	Issuer          string            // Optional; Not set by default.
	CookieName      string            // Optional; Default is DefaultAuthJWTCookieName
	CookieDomain    string            // Optional; Not set by default.
	DisableHTTPOnly bool              // Optional; By default, httponly is enabled.
	SigningMethod   jwt.SigningMethod // Optional; Default is jwt.SigningMethodHS256.
}

var ErrAuthJWTMissingSecret = errors.New("missing JWT secret")

// WithAuthJWTConfig sets JWT configuration.
// This option is required if the app is using JWT authentication.
// NewServer will panic if JWT authentication is used but this option isn't set.
func WithAuthJWTConfig(o AuthJWTConfig) ServerOption {
	return func(s *Server) error {
		if o.CookieName == "" {
			o.CookieName = DefaultAuthJWTCookieName
		}
		if len(o.Secret) < 1 {
			return ErrAuthJWTMissingSecret
		}
		if o.SigningMethod == nil {
			o.SigningMethod = jwt.SigningMethodHS256
		}
		s.authJWTOpts = &o
		return nil
	}
}

func (s *Server) mustSetSessionJWT(
	w http.ResponseWriter,
	userID, issuer, audience string,
	issuedAt time.Time,
	expire time.Time,
) {
	mSize := 4
	if audience != "" {
		mSize++
	}
	jwtClaims := make(jwt.MapClaims, mSize)
	jwtClaims["sub"] = userID
	jwtClaims["exp"] = expire.Unix()
	jwtClaims["iat"] = issuedAt.Unix()
	jwtClaims["iss"] = issuer
	if audience != "" {
		jwtClaims["aud"] = audience
	}

	token := jwt.NewWithClaims(s.authJWTOpts.SigningMethod, jwtClaims)

	signed, err := token.SignedString(s.authJWTOpts.Secret)
	if err != nil {
		panic(err)
	}

	http.SetCookie(w, &http.Cookie{
		Name:     s.authJWTOpts.CookieName,
		Value:    signed,
		Path:     "/",
		Expires:  expire,
		HttpOnly: true,
		Domain:   s.authJWTOpts.CookieDomain,
		Secure:   s.enabledTLS,
		SameSite: http.SameSiteLaxMode,
	})
}

func (s *Server) removeSessionJWT(w http.ResponseWriter) {
	http.SetCookie(w, &http.Cookie{
		Name:     s.authJWTOpts.CookieName,
		Value:    "",
		Path:     "/",
		MaxAge:   -1,
		HttpOnly: true,
		Secure:   true,
	})
}

func (s *Server) readSessionJWT(
	w http.ResponseWriter, r *http.Request,
) (sess app.SessionJWT, ok bool) {
	c, err := r.Cookie(s.authJWTOpts.CookieName)
	if err != nil {
		if errors.Is(err, http.ErrNoCookie) {
			return sess, true
		}
		return sess, false
	}

	token, err := jwt.Parse(c.Value, func(t *jwt.Token) (any, error) {
		// Hard fail on alg mismatch
		if t.Method.Alg() != s.authJWTOpts.SigningMethod.Alg() {
			return nil, jwt.ErrTokenInvalidClaims
		}
		return s.authJWTOpts.Secret, nil
	})
	if err != nil {
		if errors.Is(err, jwt.ErrTokenExpired) {
			// Clear the expired token
			s.removeSessionJWT(w)
			return sess, true
		}
		s.httpErrUnauth(w, "invalid JWT")
		return sess, false
	}

	if !token.Valid {
		s.httpErrUnauth(w, "invalid JWT")
		return sess, false
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		s.httpErrUnauth(w, "invalid JWT")
		return sess, false
	}

	if sub, err := claims.GetSubject(); err != nil {
		s.httpErrUnauth(w, "invalid JWT subject")
		return sess, false
	} else {
		sess.UserID = sub
	}
	if iss, err := claims.GetIssuedAt(); err != nil {
		s.httpErrUnauth(w, "invalid JWT iss field")
		return sess, false
	} else {
		sess.IssuedAt = iss.Time
	}
	if exp, err := claims.GetExpirationTime(); err != nil {
		s.httpErrUnauth(w, "invalid JWT exp field")
		return sess, false
	} else {
		sess.Expiration = exp.Time
	}

	return sess, true
}

// --- HTTP Handlers ---

func httpRedirect(
	w http.ResponseWriter, r *http.Request, re app.Redirect,
) (exit bool) {
	if re.Target == "" {
		return false
	}

	if isDSReq(r) {
		// Force client-side navigation via JS for Datastar requests.
		w.Header().Set("Content-Type", "text/javascript")
		_, _ = fmt.Fprintf(w, "window.location = %q;", re.Target)
		return true
	}

	switch re.Status {
	case http.StatusMovedPermanently,
		http.StatusFound,
		http.StatusSeeOther,
		http.StatusNotModified,
		http.StatusUseProxy,
		http.StatusTemporaryRedirect,
		http.StatusPermanentRedirect:
		// OK
	default:
		re.Status = http.StatusSeeOther
	}
	http.Redirect(w, r, re.Target, re.Status)
	return true
}

func setupHandlers(s *Server) {
	// Pages
	s.mux.HandleFunc(
		"POST /cause-500-internal-error/{$}",
		s.handlePOSTCause500)
	s.mux.HandleFunc(
		"POST /expire-session-jwt/{$}",
		s.handlePOSTExpireSessionJWT)
	s.mux.HandleFunc(
		"POST /sign-out/{$}",
		s.handlePageSettingsPOSTSignOut)
	s.mux.HandleFunc(
		"GET /",
		s.handlePageIndexGET)
	s.mux.HandleFunc(
		"GET /_$/{$}",
		s.handlePageIndexGETStream)
	s.mux.HandleFunc(
		"GET /not-found/{$}",
		s.handlePage404GET)
	s.mux.HandleFunc(
		"GET /whoops/{$}",
		s.handlePage500GET)
	s.mux.HandleFunc(
		"GET /login/{$}",
		s.handlePageLoginGET)
	s.mux.HandleFunc(
		"POST /login/submit/{$}",
		s.handlePageLoginPOSTSubmit)
	s.mux.HandleFunc(
		"GET /settings/{$}",
		s.handlePageSettingsGET)
	s.mux.HandleFunc(
		"GET /settings/_$/{$}",
		s.handlePageSettingsGETStream)
	s.mux.HandleFunc(
		"POST /settings/save/{$}",
		s.handlePageSettingsPOSTSave)
	s.mux.HandleFunc(
		"GET /messages/{$}",
		s.handlePageMessagesGET)
	s.mux.HandleFunc(
		"GET /messages/_$/{$}",
		s.handlePageMessagesGETStream)
	s.mux.HandleFunc(
		"POST /messages/read/{$}",
		s.handlePageMessagesPOSTRead)
	s.mux.HandleFunc(
		"POST /messages/writing/{$}",
		s.handlePageMessagesPOSTWriting)
	s.mux.HandleFunc(
		"POST /messages/writing-stopped/{$}",
		s.handlePageMessagesPOSTWritingStopped)
	s.mux.HandleFunc(
		"POST /messages/sendmessage/{$}",
		s.handlePageMessagesPOSTSendMessage)
	s.mux.HandleFunc(
		"GET /search/{$}",
		s.handlePageSearchGET)
	s.mux.HandleFunc(
		"GET /search/_$/{$}",
		s.handlePageSearchGETStream)
	s.mux.HandleFunc(
		"POST /search/paramchange/{$}",
		s.handlePageSearchPOSTParamChange)
	s.mux.HandleFunc(
		"GET /user/{name}/{$}",
		s.handlePageUserGET)
	s.mux.HandleFunc(
		"GET /post/{slug}/{$}",
		s.handlePagePostGET)
	s.mux.HandleFunc(
		"GET /post/{slug}/_$/{$}",
		s.handlePagePostGETStream)
	s.mux.HandleFunc(
		"POST /post/{slug}/send-message/{$}",
		s.handlePagePostPOSTSendMessage)
}

func (s *Server) httpErrIntern(
	w http.ResponseWriter, r *http.Request,
	sse *datastar.ServerSentEventGenerator, msg string, err error,
) {
	s.logErr(msg, err)
	if !isDSReq(r) {
		s.handlePage500GET(w, r)
		return
	}
	if sse == nil {
		sse = datastar.NewSSE(w, r, datastar.WithCompression())
	}
	errRecover := s.app.Recover500(err, sse)
	if errRecover == nil {
		return // Feedback delivered gracefully.
	}
	// Fallback to ugly 500
	s.logger.Error("recovering 500",
		slog.Any("orig.msg", msg),
		slog.Any("orig.err", err),
		slog.Any("err", errRecover))
	const code = http.StatusInternalServerError
	http.Error(w, http.StatusText(code), code)
}

func (s *Server) render404(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.Page404{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling Page404.GET", err)
		return
	}

	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for Page404", err)
		return
	}

	if err := writeHTML(w, r, genericHead, nil, body, nil); err != nil {
		s.logErr("rendering Page404", err)
		return
	}
}

func (s *Server) handlePOSTCause500(w http.ResponseWriter, r *http.Request) {
	if err := s.app.POSTCause500(r); err != nil {
		s.httpErrIntern(w, r, nil, "handling action App.POSTCause500", err)
	}
}

func (s *Server) handlePOSTExpireSessionJWT(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}
	newSessionJWT, err := s.app.POSTExpireSessionJWT(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling action App.POSTExpireSessionJWT", err)
	}
	if j := newSessionJWT; j.UserID != "" {
		s.mustSetSessionJWT(
			w, j.UserID, s.authJWTOpts.Audience, s.authJWTOpts.Issuer,
			j.IssuedAt, j.Expiration,
		)
	}
}

func (s *Server) handlePage500GET(w http.ResponseWriter, r *http.Request) {
	p := app.Page500{App: s.app}

	body, err := p.GET(r)
	if err != nil {
		// Fall back to basic 500 error page.
		s.httpErrIntern(w, r, nil, "handling Page500.GET", err)
		return
	}

	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for Page500", err)
		return
	}

	if err := writeHTML(w, r, genericHead, nil, body, nil); err != nil {
		s.logErr("rendering Page500", err)
		return
	}
}

func (s *Server) handlePageIndexGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	if r.URL.Path != "/" {
		s.render404(w, r)
		return
	}

	p := app.PageIndex{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageIndex.GET", err)
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageIndex", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) (err error) {
		_, err = io.WriteString(w, `data-init="@get('/_$')"`)
		if err != nil {
			return err
		}
		return nil
	}

	if err := writeHTML(w, r, genericHead, nil, body, bodyAttrs); err != nil {
		s.logErr("rendering PageIndex", err)
		return
	}
}

func (s *Server) handlePageIndexGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	if sess.UserID == "" {
		return
	}

	p := app.PageIndex{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	s.handleStreamRequest(w, r, evSubjPageIndex(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(sse, e, sess); err != nil {
					s.logErr("handling PageIndex.Base.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingRead):
				var e app.EventMessagingRead
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingRead JSON", err)
					continue
				}
				if err := p.OnMessagingRead(sse, e, sess); err != nil {
					s.logErr("handling PageIndex.Base.OnMessagingRead", err)
				}
			}
		}
	})
}

func (s *Server) handlePage404GET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.Page404{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling Page404.GET", err)
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for Page404", err)
		return
	}

	if err := writeHTML(w, r, genericHead, nil, body, nil); err != nil {
		s.logErr("rendering Page404", err)
		return
	}
}

func (s *Server) handlePageLoginGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.PageLogin{App: s.app}

	body, redirect, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageLogin.GET", err)
		return
	}
	if httpRedirect(w, r, redirect) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageLogin", err)
		return
	}
	if err := writeHTML(w, r, genericHead, nil, body, nil); err != nil {
		s.logErr("rendering PageLogin", err)
		return
	}
}

func (s *Server) handlePageLoginPOSTSubmit(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}
	var sig struct {
		EmailOrUsername string `json:"emailorusername"`
		Password        string `json:"password"`
	}
	if err := datastar.ReadSignals(r, &sig); err != nil {
		s.httpErrBad(w, "reading signals", err)
	}

	p := app.PageLogin{App: s.app}

	body, redirect, newSessionJWT, err := p.POSTSubmit(r, sess, sig)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageLogin.POSTSubmit", err)
		return
	}
	if j := newSessionJWT; j.UserID != "" {
		s.mustSetSessionJWT(
			w, j.UserID, s.authJWTOpts.Audience, s.authJWTOpts.Issuer,
			j.IssuedAt, j.Expiration,
		)
	}
	if httpRedirect(w, r, redirect) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageSettings", err)
		return
	}
	if err := writeHTML(w, r, genericHead, nil, body, nil); err != nil {
		s.logErr("rendering PageSettings", err)
		return
	}
}

func (s *Server) handlePageSettingsGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.PageSettings{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, redirect, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageSettings.GET", err)
		return
	}
	if httpRedirect(w, r, redirect) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageSettings", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) (err error) {
		_, err = io.WriteString(w, `data-init="@get('/settings/_$')"`)
		if err != nil {
			return err
		}
		return nil
	}

	if err := writeHTML(w, r, genericHead, nil, body, bodyAttrs); err != nil {
		s.logErr("rendering PageSettings", err)
		return
	}
}

func (s *Server) handlePageSettingsGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	if sess.UserID == "" {
		return
	}

	p := app.PageSettings{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	s.handleStreamRequest(w, r, evSubjPageSettings(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(sse, e, sess); err != nil {
					s.logErr("handling PageSettings.Base.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingRead):
				var e app.EventMessagingRead
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingRead JSON", err)
					continue
				}
				if err := p.OnMessagingRead(sse, e, sess); err != nil {
					s.logErr("handling PageSettings.Base.OnMessagingRead", err)
				}
			}
		}
	})
}

func (s *Server) handlePageSettingsPOSTSave(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}
	var sig struct {
		Username string `json:"username"`
	}
	if err := datastar.ReadSignals(r, &sig); err != nil {
		s.httpErrBad(w, "reading signals", err)
	}
	p := app.PageSettings{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())
	err := p.POSTSave(r, sse, sess, sig)
	if err != nil {
		s.httpErrIntern(w, r, sse, "handling action PageSettings.POSTSave", err)
		return
	}
}

func (s *Server) handlePageSettingsPOSTSignOut(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	removeSessionJWT, redirect, err := s.app.POSTSignOut(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageSettings.PostSignOut", err)
		return
	}
	if removeSessionJWT {
		s.removeSessionJWT(w)
	}
	if httpRedirect(w, r, redirect) {
		return
	}
}

func (s *Server) handlePageMessagesGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	q := r.URL.Query()
	var query struct {
		Chat string `query:"chat" reflectsignal:"chatselected"`
	}
	query.Chat = q.Get("chat")

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, redirect, err := p.GET(r, sess, query)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageMessages.GET", err)
		return
	}
	if httpRedirect(w, r, redirect) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageMessages", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) error {
		_, _ = io.WriteString(w, `data-signals:chatselected="'`)
		_, _ = io.WriteString(w, query.Chat)
		_, _ = io.WriteString(w, `'"`)

		_, _ = io.WriteString(w, `data-init="@get('/messages/_$')"`)

		_, _ = io.WriteString(w, `data-effect="const params = new URLSearchParams();
			if ($chatselected) params.set('chat', $chatselected);
			const query = params.toString();
			window.history.replaceState(null, '', query ? '/messages?' + query : '/messages');
		"`)
		return nil
	}

	if err := writeHTML(w, r, genericHead, nil, body, bodyAttrs); err != nil {
		s.logErr("rendering PageMessages", err)
		return
	}
}

func (s *Server) handlePageMessagesGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	if sess.UserID == "" {
		return
	}

	var signals struct {
		Chat string `json:"chatselected"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "reading signals", err)
		return
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	s.handleStreamRequest(w, r, evSubjPageMessages(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.Base.OnMessagingSent(sse, e, sess); err != nil {
					s.logErr("handling PageMessages.Base.OnMessagingSent", err)
				}
				if err := p.OnMessagingSent(sse, e, sess, signals); err != nil {
					s.logErr("handling PageMessages.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingRead):
				var e app.EventMessagingRead
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingRead JSON", err)
					continue
				}
				if err := p.Base.OnMessagingRead(sse, e, sess); err != nil {
					s.logErr("handling PageMessages.Base.OnMessagingSent", err)
				}
				if err := p.OnMessagingRead(sse, e, sess, signals); err != nil {
					s.logErr("handling PageMessages.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingWriting):
				var e app.EventMessagingWriting
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingWriting JSON", err)
					continue
				}
				if err := p.OnMessagingWriting(sse, e, sess); err != nil {
					s.logErr("handling PageMessages.OnMessagingWriting", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingWritingStopped):
				var e app.EventMessagingWritingStopped
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingWritingStopped JSON", err)
					continue
				}
				if err := p.OnMessagingWritingStopped(sse, e, sess); err != nil {
					s.logErr("handling PageMessages.OnMessagingWritingStopped", err)
				}
			}
		}
	})
}

func (s *Server) handlePageMessagesPOSTRead(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)

	q := r.URL.Query()
	var query struct {
		MessageID string `query:"msgid"`
	}
	query.MessageID = q.Get("msgid")

	var signals struct {
		ChatSelected string `json:"chatselected"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "unexpected body, expected JSON signals", err)
		return
	}

	dispatch := func(
		e1 app.EventMessagingRead,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingRead JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefMessagingRead + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	if err := p.POSTRead(r, sess, signals, query, dispatch); err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageMessages.POSTRead", err)
		return
	}
}

func (s *Server) handlePageMessagesPOSTWriting(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)

	var signals struct {
		ChatSelected string `json:"chatselected"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "unexpected body, expected JSON signals", err)
		return
	}

	dispatch := func(
		e1 app.EventMessagingWriting,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingWriting JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefMessagingWriting + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	if err := p.POSTWriting(r, sess, signals, dispatch); err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageMessages.POSTWriting", err)
		return
	}
}

func (s *Server) handlePageMessagesPOSTWritingStopped(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)

	var signals struct {
		ChatSelected string `json:"chatselected"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "unexpected body, expected JSON signals", err)
		return
	}

	dispatch := func(
		e1 app.EventMessagingWritingStopped,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingWritingStopped JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefMessagingWritingStopped + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	if err := p.POSTWritingStopped(r, sess, signals, dispatch); err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageMessages.POSTWritingStopped", err)
		return
	}
}

func (s *Server) handlePageMessagesPOSTSendMessage(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)

	var signals struct {
		ChatSelected string `json:"chatselected"`
		MessageText  string `json:"messagetext"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "unexpected body, expected JSON signals", err)
		return
	}

	dispatch := func(
		e1 app.EventMessagingWritingStopped,
		e2 app.EventMessagingSent,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingWritingStopped JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefMessagingWritingStopped + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		{
			j, err := json.Marshal(e2)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingSent JSON: %w", err)
			}
			for _, uid := range e2.TargetUserIDs {
				subj := EvSubjPrefMessagingSent + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	if err := p.POSTSendMessage(r, sess, signals, dispatch); err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageMessages.POSTSendMessage", err)
		return
	}
}

func (s *Server) handlePageSearchGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	q := r.URL.Query()
	var query app.SearchParams
	query.Term = q.Get("t")
	query.Category = q.Get("c")
	{
		if q := q.Get("pmin"); q != "" {
			i, err := strconv.ParseInt(q, 10, 64)
			if err != nil {
				s.httpErrBad(w, "unexpected value for query parameter: pmin", err)
				return
			}
			query.PriceMin = i
		}
	}
	{
		if q := q.Get("pmax"); q != "" {
			i, err := strconv.ParseInt(q, 10, 64)
			if err != nil {
				s.httpErrBad(w, "unexpected value for query parameter: pmax", err)
				return
			}
			query.PriceMin = i
		}
	}
	query.Location = q.Get("l")

	p := app.PageSearch{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, err := p.GET(r, sess, query)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageSearch.GET", err)
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageSearch", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) error {
		_, _ = io.WriteString(w, `data-signals:term="'`)
		_, _ = io.WriteString(w, query.Term)
		_, _ = io.WriteString(w, `'"`)

		_, _ = io.WriteString(w, `data-signals:category="'`)
		_, _ = io.WriteString(w, query.Category)
		_, _ = io.WriteString(w, `'"`)

		_, _ = io.WriteString(w, `data-signals:pmin="`)
		_, _ = io.WriteString(w, strconv.FormatInt(query.PriceMin, 10))
		_, _ = io.WriteString(w, `"`)

		_, _ = io.WriteString(w, `data-signals:pmax="`)
		_, _ = io.WriteString(w, strconv.FormatInt(query.PriceMax, 10))
		_, _ = io.WriteString(w, `"`)

		_, _ = io.WriteString(w, `data-signals:location="'`)
		_, _ = io.WriteString(w, query.Location)
		_, _ = io.WriteString(w, `'"`)

		_, _ = io.WriteString(w, `data-init="@get('/search/_$')"`)

		_, _ = io.WriteString(w, `data-effect="const params = new URLSearchParams();
			if ($term) params.set('t', $term);
			if ($category) params.set('c', $category);
			if ($pmin) params.set('pmin', $pmin);
			if ($pmax) params.set('pmax', $pmax);
			if ($location) params.set('l', $location);
			const query = params.toString();
			window.history.replaceState(null, '', query ? '/search?' + query : '/search');
		"`)
		return nil
	}

	if err := writeHTML(w, r, genericHead, nil, body, bodyAttrs); err != nil {
		s.logErr("rendering PageSearch", err)
		return
	}
}

func (s *Server) handlePageSearchGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	if sess.UserID == "" {
		return
	}

	p := app.PageSearch{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	s.handleStreamRequest(w, r, evSubjPageSearch(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(sse, e, sess); err != nil {
					s.logErr("handling PageSearch.Base.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingRead):
				var e app.EventMessagingRead
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingRead JSON", err)
					continue
				}
				if err := p.OnMessagingRead(sse, e, sess); err != nil {
					s.logErr("handling PageSearch.Base.OnMessagingRead", err)
				}
			}
		}
	})
}

func (s *Server) handlePageUserGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	var path struct {
		Name string `path:"name"`
	}
	path.Name = r.PathValue("name")

	p := app.PageUser{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, head, redirect, err := p.GET(r, sess, path)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageUser.GET", err)
		return
	}
	if httpRedirect(w, r, redirect) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageUser", err)
		return
	}
	if err := writeHTML(w, r, genericHead, head, body, nil); err != nil {
		s.logErr("rendering PageUser", err)
		return
	}
}

func (s *Server) handlePagePostGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	var path struct {
		Slug string `path:"slug"`
	}
	path.Slug = r.PathValue("slug")

	p := app.PagePost{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, head, redirect, err := p.GET(r, sess, path)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PagePost.GET", err)
		return
	}
	if httpRedirect(w, r, redirect) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PagePost", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) (err error) {
		_, err = io.WriteString(w, `data-init="@get('/post/`)
		if err != nil {
			return err
		}
		_, err = io.WriteString(w, path.Slug)
		if err != nil {
			return err
		}
		_, err = io.WriteString(w, `/_$')"`)
		if err != nil {
			return err
		}
		return nil
	}

	if err := writeHTML(w, r, genericHead, head, body, bodyAttrs); err != nil {
		s.logErr("rendering PagePost", err)
		return
	}
}

func (s *Server) handlePageSearchPOSTParamChange(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)

	var signals app.SearchParams
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "unexpected body, expected JSON signals", err)
		return
	}

	p := app.PageSearch{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())
	if err := p.POSTParamChange(r, sse, sess, signals); err != nil {
		s.httpErrIntern(w, r, sse, "handling action PageSearch.POSTParamChange", err)
		return
	}
}

func (s *Server) handlePagePostGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	if sess.UserID == "" {
		return
	}

	p := app.PagePost{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	s.handleStreamRequest(w, r, evSubjPagePost(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(sse, e, sess); err != nil {
					s.logErr("handling PagePost.Base.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingRead):

				var e app.EventMessagingRead
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingRead JSON", err)
					continue
				}
				if err := p.OnMessagingRead(sse, e, sess); err != nil {
					s.logErr("handling PagePost.Base.OnMessagingRead", err)
				}
			case msg.Subject == EvSubjPostArchived:
				var e app.EventPostArchived
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventPostArchived JSON", err)
					continue
				}
				if err := p.OnPostArchived(sse, e, sess); err != nil {
					s.logErr("handling PagePost.OnPostArchived", err)
				}
			}
		}
	})
}

func (s *Server) handlePagePostPOSTSendMessage(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)

	var signals struct {
		MessageText string `json:"messagetext"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "unexpected body, expected JSON signals", err)
		return
	}

	var path struct {
		Slug string `json:"slug"`
	}
	path.Slug = r.PathValue("slug")

	dispatch := func(
		e1 app.EventMessagingSent,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingSent JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefMessagingSent + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PagePost{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())
	if err := p.POSTSendMessage(r, sse, sess, path, signals, dispatch); err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageMessages.POSTSendMessage", err)
		return
	}
}
