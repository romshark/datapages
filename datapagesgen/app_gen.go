// Generated by github.com/romshark/datapages. DO NOT EDIT.

package datapagesgen

import (
	"datapages/app"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"maps"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/a-h/templ"
	"github.com/golang-jwt/jwt/v5"
	"github.com/starfederation/datastar-go/datastar"
)

// --- Message Broker ---

const (
	EvSubjMessagingSent           = "messaging.sent"
	EvSubjMessagingWriting        = "messaging.writing"
	EvSubjMessagingWritingStopped = "messaging.writing-stopped"
	EvSubjPostArchived            = "posts.archived"
)

const (
	EvSubjPrefMessagingSent           = EvSubjMessagingSent + "."
	EvSubjPrefMessagingWriting        = EvSubjMessagingWriting + "."
	EvSubjPrefMessagingWritingStopped = EvSubjMessagingWritingStopped + "."
)

func MessageBrokerStreamSubjects() []string {
	return []string{
		EvSubjMessagingSent,
		EvSubjMessagingWriting,
		EvSubjMessagingWritingStopped,
		EvSubjPostArchived,
	}
}

func evSubjPageIndex(userID string) []string {
	return []string{EvSubjPrefMessagingSent + userID}
}

func evSubjPageMessages(userID string) []string {
	return []string{
		EvSubjMessagingSent + userID,
		EvSubjMessagingWriting + userID,
		EvSubjMessagingWritingStopped + userID,
	}
}

func evSubjPagePost(userID string) []string {
	return []string{
		EvSubjPostArchived,
	}
}

func evSubjPageSearch(userID string) []string {
	return []string{
		EvSubjMessagingSent + userID,
	}
}

func evSubjPageSettings(userID string) []string {
	return []string{
		EvSubjMessagingSent + userID,
	}
}

// --- Auth: JWT ---

const DefaultAuthJWTCookieName = "sessjwt"

type AuthJWTConfig struct {
	Secret []byte

	Audience        string            // Optional; Not set by default.
	Issuer          string            // Optional; Not set by default.
	CookieName      string            // Optional; Default is DefaultAuthJWTCookieName
	CookieDomain    string            // Optional; Not set by default.
	DisableHTTPOnly bool              // Optional; By default, httponly is enabled.
	SigningMethod   jwt.SigningMethod // Optional; Default is jwt.SigningMethodHS256.
}

var ErrAuthJWTMissingSecret = errors.New("missing JWT secret")

// WithAuthJWTConfig sets JWT configuration.
// This option is required if the app is using JWT authentication.
// NewServer will panic if JWT authentication is used but this option isn't set.
func WithAuthJWTConfig(o AuthJWTConfig) ServerOption {
	return func(s *Server) error {
		if o.CookieName == "" {
			o.CookieName = DefaultAuthJWTCookieName
		}
		if len(o.Secret) < 1 {
			return ErrAuthJWTMissingSecret
		}
		if o.SigningMethod == nil {
			o.SigningMethod = jwt.SigningMethodHS256
		}
		s.authJWTOpts = &o
		return nil
	}
}

func (s *Server) mustSetSessionJWT(
	w http.ResponseWriter,
	userID, audience, issuer string,
	now, expire, notBefore time.Time, claims map[string]any,
) {
	mSize := 3 + len(claims)
	if audience != "" {
		mSize++
	}
	if issuer != "" {
		mSize++
	}
	if !notBefore.IsZero() {
		mSize++
	}

	jwtClaims := make(jwt.MapClaims, mSize)
	maps.Copy(jwtClaims, claims)
	jwtClaims["sub"] = userID
	jwtClaims["exp"] = expire.Unix()
	jwtClaims["iat"] = now.Unix()

	if audience != "" {
		jwtClaims["aud"] = audience
	}
	if issuer != "" {
		jwtClaims["iss"] = issuer
	}
	if !notBefore.IsZero() {
		jwtClaims["nbf"] = notBefore.Unix()
	}

	token := jwt.NewWithClaims(s.authJWTOpts.SigningMethod, jwtClaims)

	signed, err := token.SignedString(s.authJWTOpts)
	if err != nil {
		panic(err)
	}

	http.SetCookie(w, &http.Cookie{
		Name:     "session",
		Value:    signed,
		Path:     "/",
		Expires:  expire,
		HttpOnly: true,
		Domain:   s.authJWTOpts.CookieDomain,
		Secure:   true,
		SameSite: http.SameSiteLaxMode,
	})
}

func (s *Server) readSessionJWT(
	w http.ResponseWriter, r *http.Request,
) (sess app.SessionJWT, ok bool) {
	c, err := r.Cookie(s.authJWTOpts.CookieName)
	if err != nil {
		if errors.Is(err, http.ErrNoCookie) {
			return sess, true
		}
		return sess, false
	}

	token, err := jwt.Parse(c.Value, func(t *jwt.Token) (any, error) {
		// Hard fail on alg mismatch
		if t.Method.Alg() != s.authJWTOpts.SigningMethod.Alg() {
			return nil, jwt.ErrTokenInvalidClaims
		}
		return s.authJWTOpts.Secret, nil
	})
	if err != nil || !token.Valid {
		s.httpErrUnauth(w, "invalid JWT")
		return sess, false
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		s.httpErrUnauth(w, "invalid JWT")
		return sess, false
	}

	if sub, err := claims.GetSubject(); err != nil {
		s.httpErrUnauth(w, "invalid JWT subject")
		return sess, false
	} else {
		sess.UserID = sub
	}
	if iss, err := claims.GetIssuedAt(); err != nil {
		s.httpErrUnauth(w, "invalid JWT iss field")
		return sess, false
	} else {
		sess.IssuedAt = iss.Time
	}
	if exp, err := claims.GetExpirationTime(); err != nil {
		s.httpErrUnauth(w, "invalid JWT exp field")
		return sess, false
	} else {
		sess.Expiration = exp.Time
	}

	return sess, true
}

// --- HTTP Handlers ---

func httpRedirect(
	w http.ResponseWriter, r *http.Request, re app.Redirect,
) (exit bool) {
	if re.Target == "" {
		return false
	}
	switch re.Status {
	case http.StatusMovedPermanently,
		http.StatusFound,
		http.StatusSeeOther,
		http.StatusNotModified,
		http.StatusUseProxy,
		http.StatusTemporaryRedirect,
		http.StatusPermanentRedirect:
		// OK
	default:
		re.Status = http.StatusSeeOther
	}
	http.Redirect(w, r, re.Target, re.Status)
	return true
}

func setupHandlers(s *Server) {
	// Pages
	s.mux.HandleFunc(
		"GET /",
		s.handlePageIndexGET)
	s.mux.HandleFunc(
		"GET /_$/{$}",
		s.handlePageIndexGETStream)
	s.mux.HandleFunc(
		"GET /not-found",
		s.handlePage404GET)
	s.mux.HandleFunc(
		"GET /whoops",
		s.handlePage500GET)
	s.mux.HandleFunc(
		"GET /login/{$}",
		s.handlePageLoginGET)
	s.mux.HandleFunc(
		"POST /login/submit/{$}",
		s.handlePageLoginPOSTSubmit)
	s.mux.HandleFunc(
		"GET /settings/{$}",
		s.handlePageSettingsGET)
	s.mux.HandleFunc(
		"GET /settings/_$/{$}",
		s.handlePageSettingsGETStream)
	s.mux.HandleFunc(
		"POST /settings/save/{$}",
		s.handlePageSettingsPOSTSave)
	s.mux.HandleFunc(
		"GET /messages/{$}",
		s.handlePageMessagesGET)
	s.mux.HandleFunc(
		"GET /messages/_$/{$}",
		s.handlePageMessagesGETStream)
	s.mux.HandleFunc(
		"POST /messages/sendmessage/{$}",
		s.handlePageMessagesPOSTSendMessage)
	s.mux.HandleFunc(
		"GET /search/{$}",
		s.handlePageSearchGET)
	s.mux.HandleFunc(
		"GET /search/_$/{$}",
		s.handlePageSearchGETStream)
	s.mux.HandleFunc(
		"POST /search/paramchange/{$}",
		s.handlePageSearchPOSTParamChange)
	s.mux.HandleFunc(
		"GET /post/{id}/{$}",
		s.handlePagePostGET)
	s.mux.HandleFunc(
		"GET /post/{id}/_$/{$}",
		s.handlePagePostGETStream)
}

func (s *Server) render404(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.Page404{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, "generating Page404", err)
		return
	}

	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, "generating generic head for Page404", err)
		return
	}

	h := page404(genericHead, nil, body, nil)
	if err := h.Render(r.Context(), w); err != nil {
		s.logErr("rendering Page404", err)
		return
	}
}

func (s *Server) render500(w http.ResponseWriter, r *http.Request) {
	p := app.Page500{App: s.app}

	body, err := p.GET(r)
	if err != nil {
		// Fall back to basic 500 error page.
		s.httpErrIntern(w, r, "generating Page500", err)
		return
	}

	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, "generating generic head for Page500", err)
		return
	}

	h := page500(genericHead, nil, body, nil)
	if err := h.Render(r.Context(), w); err != nil {
		s.logErr("rendering Page500", err)
		return
	}
}

func (s *Server) handlePageIndexGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	if r.URL.Path != "/" {
		s.render404(w, r)
		return
	}

	p := app.PageIndex{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, "generating PageIndex", err)
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, "generating generic head for PageIndex", err)
		return
	}

	bodyAttrs := templ.Attributes{
		"data-init": "@get('/search/_$')",
	}

	h := pageIndex(genericHead, nil, body, bodyAttrs)
	if err := h.Render(r.Context(), w); err != nil {
		s.logErr("rendering PageIndex", err)
		return
	}
}

func (s *Server) handlePageIndexGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.PageIndex{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	s.handleStreamRequest(w, r, evSubjPageIndex(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(sse, e, sess); err != nil {
					s.logErr("handling PageIndex.OnMessagingSent", err)
				}
			}
		}
	})
}

func (s *Server) handlePage404GET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.Page404{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, "generating Page404", err)
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, "generating generic head for Page404", err)
		return
	}

	h := page404(genericHead, nil, body, nil)
	if err := h.Render(r.Context(), w); err != nil {
		s.logErr("rendering Page404", err)
		return
	}
}

func (s *Server) handlePage500GET(w http.ResponseWriter, r *http.Request) {
	p := app.Page500{App: s.app}

	body, err := p.GET(r)
	if err != nil {
		s.httpErrIntern(w, r, "generating Page500", err)
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, "generating generic head for Page500", err)
		return
	}

	h := page500(genericHead, nil, body, nil)
	if err := h.Render(r.Context(), w); err != nil {
		s.logErr("rendering Page500", err)
		return
	}
}

func (s *Server) handlePageLoginGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.PageLogin{App: s.app}

	body, redirect, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, "generating PageLogin", err)
		return
	}
	if httpRedirect(w, r, redirect) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, "generating generic head for PageLogin", err)
		return
	}
	h := pageLogin(genericHead, body)
	if err := h.Render(r.Context(), w); err != nil {
		s.logErr("rendering PageLogin", err)
		return
	}
}

func (s *Server) handlePageLoginPOSTSubmit(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	var sig struct {
		Email    string `json:"email"`
		Password string `json:"password"`
	}
	if err := datastar.ReadSignals(r, &sig); err != nil {
		s.httpErrBad(w, "reading signals")
	}

	p := app.PageLogin{App: s.app}

	setSessionJWT := func(userID string, expire time.Time, claims map[string]any) {
		s.mustSetSessionJWT(
			w, userID, s.authJWTOpts.Audience, s.authJWTOpts.Issuer,
			time.Now(), expire, time.Time{}, claims,
		)
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())

	if err := p.POSTSubmit(r, sse, setSessionJWT, sig); err != nil {
		s.httpErrIntern(w, r, "handling action PageLogin.POSTSubmit", err)
		return
	}
}

func (s *Server) handlePageSettingsGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.PageSettings{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, redirect, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, "generating PageSettings", err)
		return
	}
	if httpRedirect(w, r, redirect) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, "generating generic head for PageSettings", err)
		return
	}
	h := pageSettings(genericHead, body)
	if err := h.Render(r.Context(), w); err != nil {
		s.logErr("rendering PageSettings", err)
		return
	}
}

func (s *Server) handlePageSettingsGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.PageSettings{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	s.handleStreamRequest(w, r, evSubjPageSettings(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(sse, e, sess); err != nil {
					s.logErr("handling PageSettings.OnMessagingSent", err)
				}
			}
		}
	})
}

func (s *Server) handlePageSettingsPOSTSave(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	panic("TODO")
}

func (s *Server) handlePageMessagesGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	q := r.URL.Query()
	var query struct {
		Chat string `query:"chat" reflectsignal:"selected"`
	}
	query.Chat = q.Get("t")

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, redirect, err := p.GET(r, sess, query)
	if err != nil {
		s.httpErrIntern(w, r, "generating PageMessages", err)
		return
	}
	if httpRedirect(w, r, redirect) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, "generating generic head for PageMessages", err)
		return
	}
	h := pageMessages(genericHead, body)
	if err := h.Render(r.Context(), w); err != nil {
		s.logErr("rendering PageMessages", err)
		return
	}
}

func (s *Server) handlePageMessagesGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	s.handleStreamRequest(w, r, evSubjPageMessages(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject,
				EvSubjMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(sse, e, sess); err != nil {
					s.logErr("handling PageMessages.OnMessagingSent", err)
				}
			}
		}
	})
}

func (s *Server) handlePageMessagesPOSTSendMessage(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}
	b, err := io.ReadAll(r.Body)
	if err != nil {
		s.httpErrBad(w, "reading JSON body")
		return
	}

	var v struct {
		Chat        string `json:"chatselected"`
		MessageText string `json:"messagetext"`
	}
	if err := json.Unmarshal(b, &v); err != nil {
		s.httpErrBad(w, fmt.Sprintf("unexpected body, expected JSON signals: %v", err))
		return
	}

	dispatch := func(
		e1 app.EventMessagingWritingStopped,
		e2 app.EventMessagingSent,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingWritingStopped JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := "messaging.writing-stopped." + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		{
			j, err := json.Marshal(e2)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingSent JSON: %w", err)
			}
			for _, uid := range e2.TargetUserIDs {
				subj := "messaging.sent." + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	if err := p.POSTSendMessage(r, sess, v, dispatch); err != nil {
		s.httpErrIntern(w, r, "handling action PageSearch.POSTParamChange", err)
		return
	}
}

func (s *Server) handlePageSearchGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	q := r.URL.Query()
	var query app.SearchParams
	query.Term = q.Get("t")
	query.Category = q.Get("c")
	{
		if q := q.Get("pmin"); q != "" {
			i, err := strconv.ParseInt(q, 10, 64)
			if err != nil {
				s.httpErrBad(w, "unexpected value for query parameter: pmin")
				return
			}
			query.PriceMin = i
		}
	}
	{
		if q := q.Get("pmax"); q != "" {
			i, err := strconv.ParseInt(q, 10, 64)
			if err != nil {
				s.httpErrBad(w, "unexpected value for query parameter: pmax")
				return
			}
			query.PriceMin = i
		}
	}
	query.Location = q.Get("l")

	p := app.PageSearch{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, err := p.GET(r, sess, query)
	if err != nil {
		s.httpErrIntern(w, r, "generating PageSearch", err)
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, "generating generic head for PageSearch", err)
		return
	}

	bodyAttrs := templ.Attributes{
		"data-signals:term":     query.Term,
		"data-signals:category": query.Category,
		"data-signals:pmin":     query.PriceMin,
		"data-signals:pmax":     query.PriceMax,
		"data-signals:location": query.Location,
		"data-init":             "@get('/search/_$')",
	}

	h := pageSearch(genericHead, nil, body, bodyAttrs)
	if err := h.Render(r.Context(), w); err != nil {
		s.logErr("rendering PageSearch", err)
		return
	}
}

func (s *Server) handlePageSearchGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.PageSearch{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	s.handleStreamRequest(w, r, evSubjPageSearch(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(sse, e, sess); err != nil {
					s.logErr("handling PageSearch.OnMessagingSent", err)
				}
			}
		}
	})
}

func (s *Server) handlePagePostGET(w http.ResponseWriter, r *http.Request) {
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	var path struct {
		ID string `path:"id"`
	}
	path.ID = r.PathValue("id")

	p := app.PagePost{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	body, head, redirect, err := p.GET(r, sess, path)
	if err != nil {
		s.httpErrIntern(w, r, "generating PagePost", err)
		return
	}
	if httpRedirect(w, r, redirect) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, "generating generic head for PagePost", err)
		return
	}
	h := pagePost_id(genericHead, head, body, nil)
	if err := h.Render(r.Context(), w); err != nil {
		s.logErr("rendering PagePost", err)
		return
	}
}

func (s *Server) handlePageSearchPOSTParamChange(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}
	b, err := io.ReadAll(r.Body)
	if err != nil {
		s.httpErrBad(w, "reading JSON body")
		return
	}

	var v app.SearchParams
	if err := json.Unmarshal(b, &v); err != nil {
		s.httpErrBad(w, fmt.Sprintf("unexpected body, expected JSON signals: %v", err))
		return
	}
	if err := v.Validate(); err != nil {
		s.httpErrBad(w, "invalid signals")
		return
	}

	p := app.PageSearch{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())
	if err := p.POSTParamChange(r, sse, sess, v); err != nil {
		s.httpErrIntern(w, r, "handling action PageSearch.POSTParamChange", err)
		return
	}
}

func (s *Server) handlePagePostGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, ok := s.readSessionJWT(w, r)
	if !ok {
		return
	}

	p := app.PagePost{
		App:  s.app,
		Base: app.Base{App: s.app},
	}

	s.handleStreamRequest(w, r, evSubjPagePost(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(sse, e, sess); err != nil {
					s.logErr("handling PagePost.OnMessagingSent", err)
				}
			}
		}
	})
}
