// Generated by github.com/romshark/datapages. DO NOT EDIT.

// Package datapagesgen is generated by datapages.
package datapagesgen

import (
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"crypto/subtle"
	"datapages/app"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"os"
	"slices"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/a-h/templ"
	"github.com/nats-io/nats.go"
	"github.com/starfederation/datastar-go/datastar"
)

const (
	DefaultHTTPReadTimeout       = 15 * time.Second
	DefaultHTTPReadHeaderTimeout = 5 * time.Second
	DefaultHTTPWriteTimeout      = 15 * time.Second
	DefaultHTTPIdleTimeout       = 60 * time.Second
	DefaultHTTPMaxHeaderBytes    = 1 << 20 // 1 MB
)

// IsDevMode returns true when in the development environment.
// Returns false for production environments.
func IsDevMode() bool { return os.Getenv("TEMPL_DEV_MODE") != "" }

// MessageBroker is a common interface for message brokers.
type MessageBroker interface {
	// Subscribe creates a new subscription to a subject/stream.
	Subscribe(
		ctx context.Context, subjects ...string,
	) (MessageBrokerSubscription, error)

	// Publish sends a message to a subject (non-blocking)
	Publish(ctx context.Context, subject string, data []byte) error
}

// MessageBrokerSubscription represents an active message broker subscription.
type MessageBrokerSubscription interface {
	// C returns the channel to receive messages.
	C() <-chan Message

	// Closer closes and removes the subscription.
	Close() error
}

// Message represents a received message
type Message struct {
	Subject string
	Data    []byte
}

// ServerOption is a functional option for configuring Server
type ServerOption func(*Server) error

// WithMiddleware adds a custom middleware.
func WithMiddleware(middleware func(http.Handler) http.Handler) ServerOption {
	return func(s *Server) error {
		s.middleware = append(s.middleware, middleware)
		return nil
	}
}

// WithLogger sets a custom error logger.
// Consider setting level DEBUG when IsDevMode() returns true.
func WithLogger(l *slog.Logger) ServerOption {
	return func(s *Server) error {
		s.logger = l
		return nil
	}
}

// WithHTTPServer sets a custom HTTP server.
// The Addr and Handler fields are always overwritten.
func WithHTTPServer(server *http.Server) ServerOption {
	return func(s *Server) error {
		s.httpServer = server
		return nil
	}
}

// WithStaticFS sets a custom filesystem for serving static files at the
// specified URL path. If not provided, static file serving is disabled.
//
//	// This will serve files at URL path "/static/*" from directory "./assets".
//	subFS, err := fs.Sub(embedFS, "assets")
//	if err != nil { return err }
//	fs := http.FS(subFS)
//	//...
//	WithStaticFS("/static/", fs, nil)
//
// You may also optionally provide fsDev to use another filesystem for
// development environments. If fsDev it automatically falls back to fsProd.
// fsDev always serves static files with caching disabled.
func WithStaticFS(urlPath string, fsProd, fsDev http.FileSystem) ServerOption {
	return func(s *Server) error {
		s.staticFS = fsProd
		if IsDevMode() && fsDev != nil {
			s.staticFS = fsDev
		}
		s.staticURLPath = urlPath
		return nil
	}
}

func devNoCache(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Cache-Control", "no-store, max-age=0")
		w.Header().Set("Pragma", "no-cache")
		w.Header().Set("Expires", "0")
		next.ServeHTTP(w, r)
	})
}

// WithMessageBrokerNATS sets the default message broker.
// By default, an in-memory single-proccess broker implementation is used.
func WithMessageBrokerNATS(conn *nats.Conn, conf MessageBrokerNATSConfig) ServerOption {
	return func(s *Server) error {
		b, err := newMessageBrokerNATS(conn, conf)
		if err != nil {
			return fmt.Errorf("initializing NATS message broker: %w", err)
		}
		s.messageBroker = b
		return nil
	}
}

// WithMessageBroker sets a custom message broker.
// By default, an in-memory single-proccess broker implementation is used.
func WithMessageBroker(b MessageBroker) ServerOption {
	return func(s *Server) error {
		s.messageBroker = b
		return nil
	}
}

type CSRFConfig struct {
	Secret []byte
}

// WithCSRFProtection enables Cross-Site-Request-Forgery protection on
// POST/PUT/PATCH/DELETE action endpoints. By default CSRF protection is disabled
// but will log a warning during server initialization time.
func WithCSRFProtection(conf CSRFConfig) ServerOption {
	return func(s *Server) error {
		if len(conf.Secret) < 1 {
			return errors.New("empty CSRF secret")
		}
		s.csrfConf = &conf
		return nil
	}
}

// NewServer creates a new server instance.
// Supported options:
//
//   - WithMiddleware
//   - WithCustomErrLogger
//   - WithCustomSessionIDGenerator
//   - WithHTTPServer
//   - WithMessageBroker
//   - WithMessageBrokerNATS
func NewServer(app *app.App, opts ...ServerOption) *Server {
	s := &Server{
		shutdownCh: make(chan struct{}),
		httpServer: &http.Server{},
		app:        app,
		mux:        http.NewServeMux(),
		middleware: []func(http.Handler) http.Handler{},
	}

	// Apply options
	for _, opt := range opts {
		if err := opt(s); err != nil {
			panic(fmt.Errorf("applying server option: %w", err))
		}
	}

	// Reverse handlers such that they're invoked in the order of definition.
	slices.Reverse(s.middleware)

	// package app is using JWT authentication, hence WithAuthJWTConfig is required.
	if s.authJWTOpts == nil {
		panic("missing option WithAuthJWTConfig")
	}

	// Use defaults if not set.
	if s.logger == nil {
		opt := &slog.HandlerOptions{
			Level: slog.LevelInfo,
		}
		if IsDevMode() {
			opt.Level = slog.LevelDebug
		}
		s.logger = slog.New(slog.NewJSONHandler(os.Stderr, opt))
	}
	if s.httpServer == nil {
		s.httpServer = &http.Server{
			// Time to read request headers + body
			ReadTimeout: DefaultHTTPReadTimeout,
			// Time to read just headers (helps prevent Slowloris attacks)
			ReadHeaderTimeout: DefaultHTTPReadHeaderTimeout,
			// Time to write response
			WriteTimeout: DefaultHTTPWriteTimeout,
			// Time to wait for next request when using keep-alive
			IdleTimeout:    DefaultHTTPIdleTimeout,
			MaxHeaderBytes: DefaultHTTPMaxHeaderBytes,
		}
	}
	s.httpServer.Handler = s
	if s.httpServer.ErrorLog == nil {
		s.httpServer.ErrorLog = slog.NewLogLogger(
			slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{}),
			slog.LevelInfo,
		)
	}
	if s.messageBroker == nil {
		s.messageBroker = newMessageBrokerMem()
	}

	setupHandlers(s)
	if s.staticFS != nil {
		h := http.StripPrefix("/static/", http.FileServer(s.staticFS))
		if IsDevMode() {
			h = devNoCache(h)
		}
		s.mux.Handle("GET /static/", h)
	}

	return s
}

// ListenAndServe listens on the TCP network address addr and then calls Serve with
// handler to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
func (s *Server) ListenAndServe(hostAddress string) error {
	s.httpServer.Addr = hostAddress
	s.enabledTLS = false
	if s.csrfConf == nil {
		s.logger.Warn("CSRF protection disabled")
	}
	return s.httpServer.ListenAndServe()
}

// ListenAndServeTLS acts identically to ListenAndServe,
// except that it expects HTTPS connections.
func (s *Server) ListenAndServeTLS(hostAddress, certFile, keyFile string) error {
	s.httpServer.Addr = hostAddress
	s.enabledTLS = true
	return s.httpServer.ListenAndServeTLS(certFile, keyFile)
}

func (s *Server) Shutdown(ctx context.Context) error {
	close(s.shutdownCh) // Close all SSE subscriptions.
	return s.httpServer.Shutdown(ctx)
}

type Server struct {
	shutdownCh    chan struct{} // Closed when shutting down.
	httpServer    *http.Server
	messageBroker MessageBroker
	app           *app.App
	mux           *http.ServeMux
	logger        *slog.Logger
	middleware    []func(http.Handler) http.Handler
	staticURLPath string
	staticFS      http.FileSystem
	enabledTLS    bool

	authJWTOpts *AuthJWTConfig
	csrfConf    *CSRFConfig
}

func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Build handler chain from middleware
	handler := http.Handler(s.mux)

	// Normalize trailing slashes: ensure all paths end with /
	// except for static file paths

	if p := r.URL.Path; p != "/" && !strings.HasSuffix(p, "/") {
		// Skip normalization for static file paths
		if s.staticURLPath == "" || !strings.HasPrefix(p, s.staticURLPath) {
			// Add trailing slash for non-static paths
			r.URL.Path = p + "/"
			// Update the raw path as well if it exists
			if r.URL.RawPath != "" {
				r.URL.RawPath = r.URL.RawPath + "/"
			}
		}
	}

	// Apply middleware in reverse order so they execute in the order they were added
	for _, h := range s.middleware {
		handler = h(handler)
	}

	handler.ServeHTTP(w, r)
}

func isDSReq(r *http.Request) bool {
	return r.Header.Get("Datastar-Request") == "true"
}

func (s *Server) checkIsDSReq(w http.ResponseWriter, r *http.Request) (ok bool) {
	if !isDSReq(r) {
		s.httpErrBad(w, "not a ds request", nil)
		return false
	}
	return true
}

func (s *Server) checkCSRF(
	w http.ResponseWriter, csrfToken string, sess app.SessionJWT,
) (ok bool) {
	if sess.UserID == "" || s.csrfConf == nil {
		return true
	}
	if csrfToken == "" {
		http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
		return false
	}
	return validateCSRFTokenJWT(sess, csrfToken, s.csrfConf.Secret)
}

func (s *Server) writeHTML(
	w http.ResponseWriter,
	r *http.Request,
	sess app.SessionJWT,
	headGeneric, head, body templ.Component,
	writeBodyAttrs func(w http.ResponseWriter) error,
) error {
	_, err := io.WriteString(w, `<!DOCTYPE html><html><head><meta charset="UTF-8"/>
		<script type="module" src="/static/ds.min.js"></script>`)
	if err != nil {
		return err
	}
	if headGeneric != nil {
		if err := headGeneric.Render(r.Context(), w); err != nil {
			return err
		}
	}
	if head != nil {
		if err := head.Render(r.Context(), w); err != nil {
			return err
		}
	}
	if s.csrfConf == nil || sess.UserID == "" {
		if _, err := io.WriteString(w, "</head><body "); err != nil {
			return err
		}
	} else {
		csrfToken := generateCSRFTokenJWT(sess, s.csrfConf.Secret)
		if _, err := io.WriteString(w, `</head><body data-signals:dp_csrf="'`); err != nil {
			return err
		}
		if _, err := io.WriteString(w, csrfToken); err != nil {
			return err
		}
		if _, err := io.WriteString(w, `'" `); err != nil {
			return err
		}
	}
	if writeBodyAttrs != nil {
		if err := writeBodyAttrs(w); err != nil {
			return err
		}
	}
	if _, err := io.WriteString(w, ">"); err != nil {
		return err
	}
	if err := body.Render(r.Context(), w); err != nil {
		return err
	}
	_, err = io.WriteString(w, "</body></html>")
	return err
}

func (s *Server) handleStreamRequest(
	w http.ResponseWriter, r *http.Request,
	subjects []string,
	sessionTTL time.Duration,
	fn func(
		sse *datastar.ServerSentEventGenerator,
		ch <-chan Message,
	),
) {
	if !s.checkIsDSReq(w, r) {
		return
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())
	sub, err := s.messageBroker.Subscribe(r.Context(), subjects...)
	if err != nil {
		s.httpErrIntern(w, r, sse, "subscribing to message broker", err)
	}

	subC := sub.C()

	go func() {
		var expirationC <-chan time.Time
		if sessionTTL != 0 {
			t := time.NewTimer(sessionTTL)
			defer t.Stop()
			expirationC = t.C
		}

		// Close the subscription when the request is canceled or TTL expires.
		select {
		case <-expirationC:
		case <-r.Context().Done():
		case <-s.shutdownCh:
		}
		if err := sub.Close(); err != nil {
			s.logErr("closing message broker subscription", err)
		}
	}()

	fn(sse, subC)
}

func (s *Server) logErr(msg string, err error) {
	s.logger.Error(msg, slog.Any("err", err))
}

func (s *Server) httpErrUnauth(w http.ResponseWriter, msg string) {
	s.logger.Debug("unauthorized request", slog.String("cause", msg))
	http.Error(w, msg, http.StatusUnauthorized)
}

func (s *Server) httpErrBad(w http.ResponseWriter, msg string, err error) {
	s.logger.Debug("bad request", slog.String("cause", msg), slog.Any("err", err))
	http.Error(w, msg, http.StatusBadRequest)
}

// --- CSRF ---

func generateCSRFTokenJWT(sess app.SessionJWT, secretKey []byte) string {
	h := hmac.New(sha256.New, secretKey)
	// hash.Writer never returns an error, ignore it.
	// See: https://pkg.go.dev/hash#Hash
	_, _ = io.WriteString(h, sess.UserID)
	_, _ = io.WriteString(h, "\x00")
	_, _ = io.WriteString(h, strconv.FormatInt(sess.IssuedAt.Unix(), 16))
	_, _ = io.WriteString(h, "\x00")
	_, _ = io.WriteString(h, strconv.FormatInt(sess.Expiration.Unix(), 16))
	return base64.RawURLEncoding.EncodeToString(h.Sum(nil))
}

func validateCSRFTokenJWT(sess app.SessionJWT, token string, secretKey []byte) bool {
	expected := generateCSRFTokenJWT(sess, secretKey)
	decoded, err := base64.RawURLEncoding.DecodeString(token)
	if err != nil {
		return false
	}
	expectedBytes, err := base64.RawURLEncoding.DecodeString(expected)
	if err != nil {
		return false
	}
	return subtle.ConstantTimeCompare(decoded, expectedBytes) == 1
}

// --- MESSAGE BROKER: NATS ---

// MessageBrokerChanBuffer allows to decouple publisher/NATS callback from the consumer.
// Buffer size should be enough to absorb short bursts without blocking delivery,
// while bounding memory and ensuring slow consumers drop messages instead of
// backpressuring producers.
var MessageBrokerChanBuffer = 16

type MessageBrokerNATSConfig struct {
	StreamConfig *nats.StreamConfig
}

type messageBrokerNATS struct {
	nc *nats.Conn
	js nats.JetStreamContext
}

type natsSub struct {
	ch    chan Message
	subs  []*nats.Subscription
	close func() error
}

func newMessageBrokerNATS(
	nc *nats.Conn, conf MessageBrokerNATSConfig,
) (*messageBrokerNATS, error) {
	js, err := nc.JetStream()
	if err != nil {
		return nil, err
	}

	if conf.StreamConfig == nil {
		conf.StreamConfig = new(nats.StreamConfig)
	}
	if conf.StreamConfig.Description == "" {
		conf.StreamConfig.Description = "stream was automatically created by datapages"
	}
	conf.StreamConfig.Subjects = MessageBrokerStreamSubjects()

	_, err = js.AddStream(conf.StreamConfig)
	if err != nil && !errors.Is(err, nats.ErrStreamNameAlreadyInUse) {
		return nil, err
	}

	return &messageBrokerNATS{nc: nc, js: js}, nil
}

func (b *messageBrokerNATS) Publish(
	ctx context.Context,
	subject string,
	data []byte,
) error {
	_, err := b.js.Publish(subject, data, nats.Context(ctx))
	return err
}

func (b *messageBrokerNATS) Subscribe(
	ctx context.Context, subjects ...string,
) (MessageBrokerSubscription, error) {
	ch := make(chan Message, MessageBrokerChanBuffer)
	subs := make([]*nats.Subscription, 0, len(subjects))

	for _, subject := range subjects {
		sub, err := b.nc.Subscribe(subject, func(m *nats.Msg) {
			select {
			case ch <- Message{Subject: m.Subject, Data: m.Data}:
			default:
				// drop if subscriber is slow
			}
		})
		if err != nil {
			for _, s := range subs {
				_ = s.Unsubscribe()
			}
			close(ch)
			return nil, err
		}
		subs = append(subs, sub)
	}

	ns := &natsSub{
		ch:   ch,
		subs: subs,
	}

	ns.close = func() error {
		for _, s := range subs {
			_ = s.Unsubscribe()
		}
		close(ch)
		return nil
	}

	return ns, nil
}

func (s *natsSub) C() <-chan Message {
	return s.ch
}

func (s *natsSub) Close() error {
	if s.close == nil {
		return nil
	}
	err := s.close()
	s.close = nil // Prevent double-close
	return err
}

// --- MESSAGE BROKER: IN-MEM ---

type messageBrokerMem struct {
	lock sync.RWMutex
	subs map[string]map[*memSub]struct{}
}

type memSub struct {
	ch      chan Message
	topics  []string
	broker  *messageBrokerMem
	closed  bool
	closeMu sync.Mutex
}

func newMessageBrokerMem() *messageBrokerMem {
	return &messageBrokerMem{
		subs: make(map[string]map[*memSub]struct{}),
	}
}

func (b *messageBrokerMem) Close() error {
	return nil
}

func (b *messageBrokerMem) Publish(
	ctx context.Context,
	subject string,
	data []byte,
) error {
	b.lock.RLock()
	subs := b.subs[subject]
	b.lock.RUnlock()

	if len(subs) == 0 {
		return nil
	}

	msg := Message{
		Subject: subject,
		Data:    data,
	}

	for sub := range subs {
		select {
		case sub.ch <- msg:
		default:
			// drop if subscriber is slow (matches NATS core semantics)
		}
	}

	return nil
}

func (b *messageBrokerMem) Subscribe(
	ctx context.Context,
	subjects ...string,
) (MessageBrokerSubscription, error) {
	sub := &memSub{
		ch:     make(chan Message, MessageBrokerChanBuffer),
		topics: subjects,
		broker: b,
	}

	b.lock.Lock()
	for _, subject := range subjects {
		m, ok := b.subs[subject]
		if !ok {
			m = make(map[*memSub]struct{})
			b.subs[subject] = m
		}
		m[sub] = struct{}{}
	}
	b.lock.Unlock()

	return sub, nil
}

func (s *memSub) C() <-chan Message {
	return s.ch
}

func (s *memSub) Close() error {
	s.closeMu.Lock()
	defer s.closeMu.Unlock()

	if s.closed {
		return nil
	}
	s.closed = true

	b := s.broker
	b.lock.Lock()
	for _, subject := range s.topics {
		if m, ok := b.subs[subject]; ok {
			delete(m, s)
			if len(m) == 0 {
				delete(b.subs, subject)
			}
		}
	}
	b.lock.Unlock()

	close(s.ch)
	return nil
}
