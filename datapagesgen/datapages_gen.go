// Generated by github.com/romshark/datapages. DO NOT EDIT.

// Package datapagesgen is generated by datapages.
package datapagesgen

import (
	"context"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"crypto/subtle"
	"datapages/app"
	"encoding/base64"
	"errors"
	"fmt"
	"hash"
	"io"
	"log/slog"
	"net/http"
	"os"
	"slices"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/a-h/templ"
	"github.com/nats-io/nats.go"
	"github.com/starfederation/datastar-go/datastar"
)

const (
	DefaultHTTPReadTimeout       = 30 * time.Second
	DefaultHTTPReadHeaderTimeout = 5 * time.Second
	DefaultHTTPWriteTimeout      = 0 // SSE needs this disabled.
	DefaultHTTPIdleTimeout       = 60 * time.Second
	DefaultHTTPMaxHeaderBytes    = 1 << 20 // 1 MB
)

// IsDevMode returns true when in the development environment.
// Returns false for production environments.
func IsDevMode() bool { return os.Getenv("TEMPL_DEV_MODE") != "" }

// MessageBroker is a common interface for message brokers.
type MessageBroker interface {
	// Subscribe creates a new subscription to a subject/stream.
	Subscribe(
		ctx context.Context, subjects ...string,
	) (MessageBrokerSubscription, error)

	// Publish sends a message to a subject (non-blocking)
	Publish(ctx context.Context, subject string, data []byte) error
}

// MessageBrokerSubscription represents an active message broker subscription.
type MessageBrokerSubscription interface {
	// C returns the channel to receive messages.
	C() <-chan Message

	// Close closes and removes the subscription.
	Close()
}

// Message represents a received message
type Message struct {
	Subject string
	Data    []byte
}

// ServerOption is a functional option for configuring Server
type ServerOption func(*Server) error

// WithMiddleware adds a custom middleware.
func WithMiddleware(middleware func(http.Handler) http.Handler) ServerOption {
	return func(s *Server) error {
		s.middleware = append(s.middleware, middleware)
		return nil
	}
}

// WithLogger sets a custom error logger.
// Consider setting level DEBUG when IsDevMode() returns true.
func WithLogger(l *slog.Logger) ServerOption {
	return func(s *Server) error {
		s.logger = l
		return nil
	}
}

// WithHTTPServer sets a custom HTTP server.
// The Addr and Handler fields are always overwritten.
func WithHTTPServer(server *http.Server) ServerOption {
	return func(s *Server) error {
		s.httpServer = server
		return nil
	}
}

// WithStaticFS sets a custom filesystem for serving static files at the
// specified URL path. If not provided, static file serving is disabled.
//
//	// This will serve files at URL path "/static/*" from directory "./assets".
//	subFS, err := fs.Sub(embedFS, "assets")
//	if err != nil { return err }
//	fs := http.FS(subFS)
//	//...
//	WithStaticFS("/static/", fs, nil)
//
// You may also optionally provide fsDev to use another filesystem for
// development environments. If fsDev it automatically falls back to fsProd.
// fsDev always serves static files with caching disabled.
func WithStaticFS(urlPath string, fsProd, fsDev http.FileSystem) ServerOption {
	return func(s *Server) error {
		if urlPath == "" || urlPath[0] != '/' {
			return fmt.Errorf("static urlPath must start with '/': %q", urlPath)
		}
		if !strings.HasSuffix(urlPath, "/") {
			urlPath += "/"
		}

		s.staticFS = fsProd
		if IsDevMode() && fsDev != nil {
			s.staticFS = fsDev
		}
		s.staticURLPath = urlPath
		return nil
	}
}

func devNoCache(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Cache-Control", "no-store, max-age=0")
		w.Header().Set("Pragma", "no-cache")
		w.Header().Set("Expires", "0")
		next.ServeHTTP(w, r)
	})
}

// WithMessageBrokerNATS sets the default message broker.
// By default, an in-memory single-proccess broker implementation is used.
func WithMessageBrokerNATS(conn *nats.Conn, conf MessageBrokerNATSConfig) ServerOption {
	return func(s *Server) error {
		b, err := newMessageBrokerNATS(conn, conf)
		if err != nil {
			return fmt.Errorf("initializing NATS message broker: %w", err)
		}
		s.messageBroker = b
		return nil
	}
}

// WithMessageBroker sets a custom message broker.
// By default, an in-memory single-proccess broker implementation is used.
func WithMessageBroker(b MessageBroker) ServerOption {
	return func(s *Server) error {
		s.messageBroker = b
		return nil
	}
}

type CSRFConfig struct {
	Secret []byte
}

// WithCSRFProtection enables Cross-Site-Request-Forgery protection on
// POST/PUT/PATCH/DELETE action endpoints. By default CSRF protection is disabled
// but will log a warning during server initialization time.
func WithCSRFProtection(conf CSRFConfig) ServerOption {
	return func(s *Server) error {
		if len(conf.Secret) < 1 {
			return errors.New("empty CSRF secret")
		}
		s.csrfConf = &conf
		return nil
	}
}

// NewServer creates a new server instance.
// Supported options:
//
//   - WithMiddleware
//   - WithCustomErrLogger
//   - WithCustomSessionIDGenerator
//   - WithHTTPServer
//   - WithMessageBroker
//   - WithMessageBrokerNATS
func NewServer(app *app.App, opts ...ServerOption) *Server {
	s := &Server{
		shutdownCh: make(chan struct{}),
		httpServer: &http.Server{
			// Time to read request headers + body
			ReadTimeout: DefaultHTTPReadTimeout,
			// Time to read just headers (helps prevent Slowloris attacks)
			ReadHeaderTimeout: DefaultHTTPReadHeaderTimeout,
			// Time to write response
			WriteTimeout: DefaultHTTPWriteTimeout,
			// Time to wait for next request when using keep-alive
			IdleTimeout:    DefaultHTTPIdleTimeout,
			MaxHeaderBytes: DefaultHTTPMaxHeaderBytes,
		},
		app:        app,
		mux:        http.NewServeMux(),
		middleware: []func(http.Handler) http.Handler{},
	}

	// Apply options
	for _, opt := range opts {
		if err := opt(s); err != nil {
			panic(fmt.Errorf("applying server option: %w", err))
		}
	}

	// Reverse handlers such that they're invoked in the order of definition.
	slices.Reverse(s.middleware)

	// package app is using JWT authentication, hence WithAuthJWTConfig is required.
	if s.authJWTOpts == nil {
		panic("missing option WithAuthJWTConfig")
	}

	// Use defaults if not set.
	if s.logger == nil {
		opt := &slog.HandlerOptions{
			Level: slog.LevelInfo,
		}
		if IsDevMode() {
			opt.Level = slog.LevelDebug
		}
		s.logger = slog.New(slog.NewJSONHandler(os.Stderr, opt))
	}
	s.httpServer.Handler = s
	if s.httpServer.ErrorLog == nil {
		s.httpServer.ErrorLog = slog.NewLogLogger(
			slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{}),
			slog.LevelInfo,
		)
	}
	if s.messageBroker == nil {
		s.messageBroker = newMessageBrokerMem()
	}

	if s.csrfConf != nil {
		s.csrfHMACPool.New = func() any {
			return &csrfGenerationContext{
				hmac:         hmac.New(sha256.New, s.csrfConf.Secret),
				decodedToken: make([]byte, 64),
				issuedAtHex:  make([]byte, 16),
				base:         make([]byte, 32),
				expectedBase: make([]byte, 32),
				mask:         make([]byte, 32),
				out:          make([]byte, 64),
			}
		}
	}

	setupHandlers(s)
	if s.staticFS != nil {
		h := http.StripPrefix("/static/", http.FileServer(s.staticFS))
		if IsDevMode() {
			h = devNoCache(h)
		}
		s.mux.Handle("GET /static/", h)
	}

	return s
}

// ListenAndServe listens on the TCP network address addr and then calls Serve with
// handler to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
func (s *Server) ListenAndServe(hostAddress string) error {
	s.httpServer.Addr = hostAddress
	s.enabledTLS = false
	if s.csrfConf == nil {
		s.logger.Warn("CSRF protection disabled")
	}
	return s.httpServer.ListenAndServe()
}

// ListenAndServeTLS acts identically to ListenAndServe,
// except that it expects HTTPS connections.
func (s *Server) ListenAndServeTLS(hostAddress, certFile, keyFile string) error {
	s.httpServer.Addr = hostAddress
	s.enabledTLS = true
	return s.httpServer.ListenAndServeTLS(certFile, keyFile)
}

// Closes all SSE subscriptions and shuts down the underlying HTTP server.
func (s *Server) Shutdown(ctx context.Context) error {
	s.shutdownOnce.Do(func() {
		close(s.shutdownCh) // Close all SSE subscriptions.
	})
	return s.httpServer.Shutdown(ctx)
}

type Server struct {
	shutdownCh    chan struct{} // Closed when shutting down.
	shutdownOnce  sync.Once
	httpServer    *http.Server
	messageBroker MessageBroker
	app           *app.App
	mux           *http.ServeMux
	logger        *slog.Logger
	middleware    []func(http.Handler) http.Handler
	staticURLPath string
	staticFS      http.FileSystem
	enabledTLS    bool

	authJWTOpts  *AuthJWTConfig
	csrfConf     *CSRFConfig
	csrfHMACPool sync.Pool
}

type csrfGenerationContext struct {
	hmac         hash.Hash
	decodedToken []byte
	issuedAtHex  []byte
	base         []byte
	expectedBase []byte
	mask         []byte
	out          []byte
}

func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Build handler chain from middleware
	handler := http.Handler(s.mux)

	// Normalize trailing slashes: ensure all paths end with /
	// except for static file paths

	if p := r.URL.Path; p != "/" && !strings.HasSuffix(p, "/") {
		// Skip normalization for static file paths
		if s.staticURLPath == "" || !strings.HasPrefix(p, s.staticURLPath) {
			// Add trailing slash for non-static paths
			r.URL.Path = p + "/"
			// Update the raw path as well if it exists
			if r.URL.RawPath != "" {
				r.URL.RawPath = r.URL.RawPath + "/"
			}
		}
	}

	// Apply middleware in reverse order so they execute in the order they were added
	for _, h := range s.middleware {
		handler = h(handler)
	}

	handler.ServeHTTP(w, r)
}

func isDSReq(r *http.Request) bool {
	return r.Header.Get("Datastar-Request") == "true"
}

func (s *Server) checkIsDSReq(w http.ResponseWriter, r *http.Request) (ok bool) {
	if !isDSReq(r) {
		s.logger.Debug("not a datastar request",
			slog.Any("method", r.Method),
			slog.String("path", r.URL.Path))
		http.Error(w, http.StatusText(http.StatusNotAcceptable), http.StatusNotAcceptable)
		return false
	}
	return true
}

func (s *Server) checkCSRF(
	w http.ResponseWriter, r *http.Request, sess app.SessionJWT,
) (ok bool) {
	if sess.UserID == "" ||
		r.Method == http.MethodGet ||
		r.Method == http.MethodOptions ||
		r.Method == http.MethodHead ||
		s.csrfConf == nil {
		return true
	}
	t := r.Header.Get("X-CSRF-Token")
	if t == "" {
		http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
		return false
	}
	if !s.validateCSRFToken(sess.UserID, sess.IssuedAt, t) {
		http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
		return false
	}
	return true
}

func (s *Server) writeHTML(
	w http.ResponseWriter,
	r *http.Request,
	sess app.SessionJWT,
	headGeneric, head, body templ.Component,
	writeBodyAttrs func(w http.ResponseWriter),
) error {
	_, err := io.WriteString(w, `<!DOCTYPE html><html><head><meta charset="UTF-8"/>
		<script type="module" src="/static/ds.min.js"></script>`)
	if err != nil {
		return err
	}
	if headGeneric != nil {
		if err := headGeneric.Render(r.Context(), w); err != nil {
			return err
		}
	}
	if head != nil {
		if err := head.Render(r.Context(), w); err != nil {
			return err
		}
	}
	if s.csrfConf != nil && sess.UserID != "" {
		csrfToken := s.generateCSRFToken(sess.UserID, sess.IssuedAt)
		if csrfToken != "" {
			// Write the fetch X-CSRF-Token header injector.
			if _, err := io.WriteString(w, `
	<script type="module">
		const o = globalThis.fetch.bind(globalThis)
		globalThis.fetch=(i,init={}) => {
			const isReq=i instanceof Request
			const r=isReq ? i:new Request(i,init)
			if (r.headers.get("Datastar-Request")!=="true" ||
				r.method=="GET"||r.method=="HEAD"||r.method=="OPTIONS"
			) return isReq ? o(r,init):o(r)
			const h=new Headers(r.headers)
			h.set("X-CSRF-Token",'`); err != nil {
				return err
			}
			if _, err := io.WriteString(w, csrfToken); err != nil {
				return err
			}
			if _, err := io.WriteString(w, `')
			return o(new Request(r,{...init,headers:h}))
		}
	</script>`); err != nil {
				return err
			}
		} else {
			s.logger.Warn("generated empty CSRF token",
				slog.String("user-id", sess.UserID),
				slog.Time("issued-at", sess.IssuedAt))
		}
	}
	if _, err := io.WriteString(w, "</head><body "); err != nil {
		return err
	}
	if writeBodyAttrs != nil {
		writeBodyAttrs(w)
	}
	if _, err := io.WriteString(w, ">"); err != nil {
		return err
	}
	if err := body.Render(r.Context(), w); err != nil {
		return err
	}
	_, err = io.WriteString(w, "</body></html>")
	return err
}

func (s *Server) handleStreamRequest(
	w http.ResponseWriter, r *http.Request,
	subjects []string,
	sessionTTL time.Duration,
	fn func(
		sse *datastar.ServerSentEventGenerator,
		ch <-chan Message,
	),
) {
	if !s.checkIsDSReq(w, r) {
		return
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())
	sub, err := s.messageBroker.Subscribe(r.Context(), subjects...)
	if err != nil {
		s.httpErrIntern(w, r, sse, "subscribing to message broker", err)
		return
	}

	subC := sub.C()

	go func() {
		var expirationC <-chan time.Time
		if sessionTTL != 0 {
			t := time.NewTimer(sessionTTL)
			defer t.Stop()
			expirationC = t.C
		}

		// Close the subscription when the request is canceled or TTL expires.
		select {
		case <-expirationC:
		case <-r.Context().Done():
		case <-s.shutdownCh:
		}
		sub.Close()
	}()

	fn(sse, subC)
}

func (s *Server) logErr(msg string, err error) {
	s.logger.Error(msg, slog.Any("err", err))
}

func (s *Server) httpErrUnauth(w http.ResponseWriter, msg string) {
	s.logger.Debug("unauthorized request", slog.String("cause", msg))
	http.Error(w, msg, http.StatusUnauthorized)
}

func (s *Server) httpErrBad(w http.ResponseWriter, msg string, err error) {
	s.logger.Debug("bad request", slog.String("cause", msg), slog.Any("err", err))
	http.Error(w, msg, http.StatusBadRequest)
}

// --- CSRF ---

// withNewCSRFCtx derives a stable, per-session base secret value in the context.
func (s *Server) withNewCSRFCtx(
	userID string, sessIssuedAtUnix int64,
	withContext func(*csrfGenerationContext),
) {
	cgc := s.csrfHMACPool.Get().(*csrfGenerationContext)
	defer s.csrfHMACPool.Put(cgc)

	cgc.hmac.Reset()
	// Ensures the CSRF token is only valid for this user.
	_, _ = cgc.hmac.Write([]byte(userID))
	// Separator avoids ambiguity ("ab"+"12" vs "a"+"b12").
	_, _ = cgc.hmac.Write([]byte{0})
	// Bind token to a specific session preventing reuse across re-authentication.
	cgc.issuedAtHex = strconv.AppendInt(cgc.issuedAtHex[:0], sessIssuedAtUnix, 16)
	_, _ = cgc.hmac.Write(cgc.issuedAtHex)

	cgc.base = cgc.hmac.Sum(cgc.base[:0])
	withContext(cgc)
}

// generateCSRFToken returns the value sent to the browser.
// This uses the same masking technique as gorilla/csrf to prevent BREACH attacks:
//   - A random mask is generated per response.
//   - The real token is XORed with the mask.
//   - The mask is prepended so the server can reverse it.
func (s *Server) generateCSRFToken(userID string, sessIssuedAt time.Time) (t string) {
	u := sessIssuedAt.Unix()
	if u < 0 {
		return ""
	}
	s.withNewCSRFCtx(userID, u, func(cgc *csrfGenerationContext) {
		if _, err := rand.Read(cgc.mask); err != nil {
			panic(err) // rand.Read should never fail on a healthy system.
		}

		// [ mask | masked_token ]
		copy(cgc.out, cgc.mask)

		// XOR hides the real token while remaining reversible
		for i := range 32 {
			cgc.out[32+i] = cgc.base[i] ^ cgc.mask[i]
		}
		t = base64.RawURLEncoding.EncodeToString(cgc.out)
	})
	return t
}

// validateCSRFToken verifies a client-supplied token.
func (s *Server) validateCSRFToken(
	userID string, sessIssuedAt time.Time, token string,
) (ok bool) {
	u := sessIssuedAt.Unix()
	if len(token) != 86 || u < 0 {
		return false
	}
	s.withNewCSRFCtx(userID, u, func(cgc *csrfGenerationContext) {
		n, err := base64.RawURLEncoding.Decode(cgc.decodedToken, []byte(token))
		if err != nil || n != 64 {
			ok = false
			return
		}

		// [ mask | masked_token ]
		mask, enc := cgc.decodedToken[:32], cgc.decodedToken[32:]
		// Reverse XOR to recover the real token
		for i := range 32 {
			cgc.expectedBase[i] = enc[i] ^ mask[i]
		}
		// Recompute what the token SHOULD be for this session and compare.
		ok = subtle.ConstantTimeCompare(cgc.expectedBase, cgc.base) == 1
	})
	return ok
}

// --- MESSAGE BROKER: NATS ---

// MessageBrokerChanBuffer allows to decouple publisher/NATS callback from the consumer.
// Buffer size should be enough to absorb short bursts without blocking delivery,
// while bounding memory and ensuring slow consumers drop messages instead of
// backpressuring producers.
var MessageBrokerChanBuffer = 16

type MessageBrokerNATSConfig struct {
	StreamConfig *nats.StreamConfig
}

type messageBrokerNATS struct {
	nc *nats.Conn
	js nats.JetStreamContext
}

type natsSub struct {
	ch    chan Message
	subs  []*nats.Subscription
	close func()
}

func newMessageBrokerNATS(
	nc *nats.Conn, conf MessageBrokerNATSConfig,
) (*messageBrokerNATS, error) {
	js, err := nc.JetStream()
	if err != nil {
		return nil, err
	}

	if conf.StreamConfig == nil {
		conf.StreamConfig = new(nats.StreamConfig)
	}
	if conf.StreamConfig.Description == "" {
		conf.StreamConfig.Description = "stream was automatically created by datapages"
	}
	conf.StreamConfig.Subjects = MessageBrokerStreamSubjects()

	_, err = js.AddStream(conf.StreamConfig)
	if err != nil && !errors.Is(err, nats.ErrStreamNameAlreadyInUse) {
		return nil, err
	}

	return &messageBrokerNATS{nc: nc, js: js}, nil
}

func (b *messageBrokerNATS) Publish(
	ctx context.Context,
	subject string,
	data []byte,
) error {
	_, err := b.js.Publish(subject, data, nats.Context(ctx))
	return err
}

func (b *messageBrokerNATS) Subscribe(
	_ context.Context, subjects ...string,
) (MessageBrokerSubscription, error) {
	ch := make(chan Message, MessageBrokerChanBuffer)
	subs := make([]*nats.Subscription, 0, len(subjects))

	var (
		lock     sync.Mutex
		closing  bool
		inflight sync.WaitGroup
		once     sync.Once
	)

	closeAll := func() {
		once.Do(func() {
			// After this, no callback can call wg.Add(1).
			lock.Lock()
			closing = true
			lock.Unlock()
			// Stop NATS deliveries.
			for _, s := range subs {
				_ = s.Unsubscribe()
			}
			// Wait until all callbacks that already registered complete.
			inflight.Wait()
			close(ch)
		})
	}

	for _, subject := range subjects {
		sub, err := b.nc.Subscribe(subject, func(m *nats.Msg) {
			// Registration is serialized with closeAll() so Add never races with Wait.
			lock.Lock()
			if closing {
				lock.Unlock()
				return
			}
			// Add must be done under lock to prevent it from racing with wg.Wait.
			// WaitGroup requires that no new Add happens once Wait may be running.
			inflight.Add(1)
			lock.Unlock()

			defer inflight.Done()

			select {
			case ch <- Message{Subject: m.Subject, Data: m.Data}:
			default: // drop if subscriber is slow
			}
		})
		if err != nil {
			// Undo already-created subscriptions safely (no send-to-closed-ch races).
			closeAll()
			return nil, err
		}
		subs = append(subs, sub)
	}

	ns := &natsSub{
		ch:   ch,
		subs: subs,
	}
	ns.close = closeAll
	return ns, nil
}

func (s *natsSub) C() <-chan Message {
	return s.ch
}

func (s *natsSub) Close() {
	if s.close == nil {
		return
	}
	s.close()
	s.close = nil // Prevent double-close
}

// --- MESSAGE BROKER: IN-MEM ---

type messageBrokerMem struct {
	lock sync.RWMutex
	subs map[string]map[*memSub]struct{}
}

type memSub struct {
	ch      chan Message
	topics  []string
	broker  *messageBrokerMem
	closed  bool
	closeMu sync.Mutex
}

func newMessageBrokerMem() *messageBrokerMem {
	return &messageBrokerMem{
		subs: make(map[string]map[*memSub]struct{}),
	}
}

func (b *messageBrokerMem) Close() error {
	return nil
}

func (b *messageBrokerMem) Publish(
	ctx context.Context,
	subject string,
	data []byte,
) error {
	b.lock.RLock()
	defer b.lock.RUnlock()
	subs := b.subs[subject]

	if len(subs) == 0 {
		return nil
	}

	msg := Message{
		Subject: subject,
		Data:    data,
	}

	for sub := range subs {
		select {
		case sub.ch <- msg:
		default:
			// drop if subscriber is slow (matches NATS core semantics)
		}
	}

	return nil
}

func (b *messageBrokerMem) Subscribe(
	ctx context.Context,
	subjects ...string,
) (MessageBrokerSubscription, error) {
	sub := &memSub{
		ch:     make(chan Message, MessageBrokerChanBuffer),
		topics: subjects,
		broker: b,
	}

	b.lock.Lock()
	for _, subject := range subjects {
		m, ok := b.subs[subject]
		if !ok {
			m = make(map[*memSub]struct{})
			b.subs[subject] = m
		}
		m[sub] = struct{}{}
	}
	b.lock.Unlock()

	return sub, nil
}

func (s *memSub) C() <-chan Message {
	return s.ch
}

func (s *memSub) Close() {
	s.closeMu.Lock()
	defer s.closeMu.Unlock()

	if s.closed {
		return
	}
	s.closed = true

	b := s.broker
	b.lock.Lock()
	for _, subject := range s.topics {
		if m, ok := b.subs[subject]; ok {
			delete(m, s)
			if len(m) == 0 {
				delete(b.subs, subject)
			}
		}
	}
	b.lock.Unlock()

	close(s.ch)
}
