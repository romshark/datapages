// Generated by github.com/romshark/datapages. DO NOT EDIT.

// Package datapagesgen is generated by datapages.
package datapagesgen

import (
	"context"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/romshark/datapages/example/classifieds/app"
	"github.com/romshark/datapages/modules/csrf"
	"github.com/romshark/datapages/modules/msgbroker"

	"github.com/a-h/templ"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/starfederation/datastar-go/datastar"
	"golang.org/x/sync/errgroup"
)

const (
	DefaultHTTPReadTimeout       = 30 * time.Second
	DefaultHTTPReadHeaderTimeout = 5 * time.Second
	DefaultHTTPWriteTimeout      = 0 // SSE needs this disabled.
	DefaultHTTPIdleTimeout       = 60 * time.Second
	DefaultHTTPMaxHeaderBytes    = 1 << 20 // 1 MB
)

// IsDevMode returns true when in the development environment.
// Returns false for production environments.
func IsDevMode() bool { return os.Getenv("TEMPL_DEV_MODE") != "" }

// ServerOption is a functional option for configuring Server
type ServerOption func(*Server) error

// WithMiddleware adds a custom middleware.
func WithMiddleware(middleware func(http.Handler) http.Handler) ServerOption {
	return func(s *Server) error {
		s.middleware = append(s.middleware, middleware)
		return nil
	}
}

// WithLogger sets a custom error logger.
// Consider setting level DEBUG when IsDevMode() returns true.
func WithLogger(l *slog.Logger) ServerOption {
	return func(s *Server) error {
		s.logger = l
		return nil
	}
}

// WithHTTPServer sets a custom HTTP server.
// The Addr and Handler fields are always overwritten.
func WithHTTPServer(server *http.Server) ServerOption {
	return func(s *Server) error {
		s.httpServer = server
		return nil
	}
}

// WithStaticFS sets a custom filesystem for serving static files at the
// specified URL path. If not provided, static file serving is disabled.
//
//	// This will serve files at URL path "/static/*" from directory "./assets".
//	subFS, err := fs.Sub(embedFS, "assets")
//	if err != nil { return err }
//	fs := http.FS(subFS)
//	//...
//	WithStaticFS("/static/", fs, nil)
//
// You may also optionally provide fsDev to use another filesystem for
// development environments. If fsDev it automatically falls back to fsProd.
// fsDev always serves static files with caching disabled.
func WithStaticFS(urlPath string, fsProd, fsDev http.FileSystem) ServerOption {
	return func(s *Server) error {
		if urlPath == "" || urlPath[0] != '/' {
			return fmt.Errorf("static urlPath must start with '/': %q", urlPath)
		}
		if !strings.HasSuffix(urlPath, "/") {
			urlPath += "/"
		}

		s.staticFS = fsProd
		if IsDevMode() && fsDev != nil {
			s.staticFS = fsDev
		}
		s.staticURLPath = urlPath
		return nil
	}
}

func devNoCache(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Cache-Control", "no-store, max-age=0")
		w.Header().Set("Pragma", "no-cache")
		w.Header().Set("Expires", "0")
		next.ServeHTTP(w, r)
	})
}

type CSRFConfig struct {
	TokenManager csrf.TokenManager

	// DevBypassToken, if non-empty, is accepted as a valid
	// CSRF token for any session. Use this only in development
	// to allow tools like k6 to exercise POST endpoints.
	DevBypassToken string
}

// WithCSRFProtection enables Cross-Site-Request-Forgery protection on
// POST/PUT/PATCH/DELETE action endpoints. By default CSRF protection is disabled
// but will log a warning during server initialization time.
func WithCSRFProtection(conf CSRFConfig) ServerOption {
	return func(s *Server) error {
		if conf.TokenManager == nil {
			return errors.New("nil CSRF token manager")
		}
		if conf.DevBypassToken != "" && !IsDevMode() {
			return errors.New("CSRF dev bypass token must not be set in non-dev mode")
		}
		s.csrfConf = &conf
		return nil
	}
}

// datapagesgen/server.go (generated)

// WithPrometheus starts a dedicated HTTP server exposing /metrics.
// Example host address: "127.0.0.1:9091" or ":9091".
func WithPrometheus(conf PrometheusConfig) ServerOption {
	return func(s *Server) error {
		if conf.Host == "" {
			return errors.New("prometheus host address must not be empty")
		}

		// Defaults
		if conf.Registerer == nil {
			conf.Registerer = prometheus.DefaultRegisterer
		}
		if conf.Gatherer == nil {
			conf.Gatherer = prometheus.DefaultGatherer
		}

		// Register built-in metrics on the configured registerer exactly once.
		registerPrometheusMetricsOnce.Do(func() {
			registerMetricsWith(conf.Registerer)
		})

		// Register user-defined collectors.
		for _, c := range conf.Collectors {
			conf.Registerer.MustRegister(c)
		}

		var h http.Handler
		if conf.Handler != nil {
			h = conf.Handler
		} else {
			h = promhttp.HandlerFor(conf.Gatherer, promhttp.HandlerOpts{})
		}

		mux := http.NewServeMux()
		mux.Handle("/metrics", h)

		s.metricsServer = &http.Server{
			Addr:    conf.Host,
			Handler: mux,
		}
		return nil
	}
}

type PrometheusConfig struct {
	Host       string
	Registerer prometheus.Registerer  // Optional, default: prometheus.DefaultRegisterer
	Gatherer   prometheus.Gatherer    // Optional, default: prometheus.DefaultGatherer
	Handler    http.Handler           // Optional override
	Collectors []prometheus.Collector // User-defined metrics to register
}

var registerPrometheusMetricsOnce sync.Once

func (s *Server) listenAndServe(
	ctx context.Context,
	listenAndServe func() error,
) error {
	ctx, cancel := context.WithCancel(ctx)
	s.runCancel = cancel

	if s.csrfConf == nil {
		s.logger.Warn("CSRF protection disabled")
	}

	g, ctx := errgroup.WithContext(ctx)

	// Main frontend server
	g.Go(func() error {
		if err := listenAndServe(); err != nil &&
			!errors.Is(err, http.ErrServerClosed) {
			return err
		}
		return nil
	})

	// Metrics server
	if s.metricsServer != nil {
		s.metricsServer.BaseContext = func(net.Listener) context.Context {
			return ctx
		}
		g.Go(func() error {
			err := s.metricsServer.ListenAndServe()
			if err != nil && !errors.Is(err, http.ErrServerClosed) {
				return fmt.Errorf("metrics server failed: %w", err)
			}
			return nil
		})
	}

	// Coordinated shutdown
	g.Go(func() error {
		<-ctx.Done()

		shutdownCtx, cancel := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)
		defer cancel()

		_ = s.Shutdown(shutdownCtx)
		return nil
	})

	return g.Wait()
}

// ListenAndServe starts the main HTTP server and, if configured, a dedicated
// Prometheus metrics server.
//
// Both servers run concurrently and share the same lifecycle.
// If either server fails to start or exits unexpectedly, the other is
// shut down and the error is returned.
//
// The provided context controls graceful shutdown for both servers.
func (s *Server) ListenAndServe(
	ctx context.Context,
	addr string,
) error {
	s.httpServer.Addr = addr
	s.enabledTLS = false
	return s.listenAndServe(ctx, func() error {
		s.logger.Info("listening HTTP", slog.String("addr", addr))
		return s.httpServer.ListenAndServe()
	})
}

// ListenAndServeTLS acts identically to ListenAndServe,
// except that it expects HTTPS connections.
func (s *Server) ListenAndServeTLS(
	ctx context.Context,
	addr, certFile, keyFile string,
) error {
	s.httpServer.Addr = addr
	s.enabledTLS = true
	return s.listenAndServe(ctx, func() error {
		s.logger.Info("listening HTTP",
			slog.String("addr", addr),
			slog.String("tls.cert", certFile),
			slog.String("tls.key", keyFile))
		return s.httpServer.ListenAndServeTLS(certFile, keyFile)
	})
}

// Shutdown gracefully shuts down all server components,
// including the main HTTP server and the Prometheus metrics server.
func (s *Server) Shutdown(ctx context.Context) error {
	s.shutdownOnce.Do(func() {
		s.logger.Info("server shutdown initiated")
		if s.runCancel != nil {
			s.runCancel()
		}
		close(s.shutdownCh)
	})
	var errs []error
	if s.metricsServer != nil {
		if err := s.metricsServer.Shutdown(ctx); err != nil {
			errs = append(errs, err)
		}
	}
	if err := s.httpServer.Shutdown(ctx); err != nil {
		errs = append(errs, err)
	}
	return errors.Join(errs...)
}

func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Build handler chain from middleware
	handler := http.Handler(s.mux)

	// Normalize trailing slashes: ensure all paths end with /
	// except for static file paths

	if p := r.URL.Path; p != "/" && !strings.HasSuffix(p, "/") {
		// Skip normalization for static file paths
		if s.staticURLPath == "" || !strings.HasPrefix(p, s.staticURLPath) {
			// Add trailing slash for non-static paths
			r.URL.Path = p + "/"
			// Update the raw path as well if it exists
			if r.URL.RawPath != "" {
				r.URL.RawPath = r.URL.RawPath + "/"
			}
		}
	}

	// Apply middleware in reverse order so they execute in the order they were added
	for _, h := range s.middleware {
		handler = h(handler)
	}

	handler.ServeHTTP(w, r)
}

func isDSReq(r *http.Request) bool {
	return r.Header.Get("Datastar-Request") == "true"
}

func (s *Server) checkIsDSReq(w http.ResponseWriter, r *http.Request) (ok bool) {
	if !isDSReq(r) {
		s.logger.Debug("not a datastar request",
			slog.Any("method", r.Method),
			slog.String("path", r.URL.Path))
		http.Error(w, http.StatusText(http.StatusNotAcceptable), http.StatusNotAcceptable)
		return false
	}
	return true
}

func (s *Server) checkCSRF(
	w http.ResponseWriter, r *http.Request, sess app.Session,
) (ok bool) {
	if sess.UserID == "" ||
		r.Method == http.MethodGet ||
		r.Method == http.MethodOptions ||
		r.Method == http.MethodHead ||
		s.csrfConf == nil {
		return true
	}
	t := r.Header.Get("X-CSRF-Token")
	if t == "" {
		http.Error(
			w,
			http.StatusText(http.StatusForbidden),
			http.StatusForbidden,
		)
		return false
	}
	if s.csrfConf.DevBypassToken != "" &&
		t == s.csrfConf.DevBypassToken {
		return true
	}
	if !s.csrfConf.TokenManager.ValidateToken(sess.UserID, sess.IssuedAt.Unix(), t) {
		http.Error(
			w,
			http.StatusText(http.StatusForbidden),
			http.StatusForbidden,
		)
		return false
	}
	return true
}

func (s *Server) writeHTML(
	w http.ResponseWriter,
	r *http.Request,
	sess app.Session,
	headGeneric, head, body templ.Component,
	writeBodyAttrs func(w http.ResponseWriter),
) error {
	_, err := io.WriteString(w, `<!DOCTYPE html><html><head><meta charset="UTF-8"/>
		<script type="module" src="/static/ds.min.js"></script>`)
	if err != nil {
		return err
	}
	if headGeneric != nil {
		if err := headGeneric.Render(r.Context(), w); err != nil {
			return err
		}
	}
	if head != nil {
		if err := head.Render(r.Context(), w); err != nil {
			return err
		}
	}
	if s.csrfConf != nil && sess.UserID != "" {
		csrfToken := s.csrfConf.TokenManager.GenerateToken(
			sess.UserID, sess.IssuedAt.Unix(),
		)
		if csrfToken != "" {
			// Write the fetch X-CSRF-Token header injector.
			if _, err := io.WriteString(w, `
	<script type="module">
		const o = globalThis.fetch.bind(globalThis)
		globalThis.fetch=(i,init={}) => {
			const isReq=i instanceof Request
			const r=isReq ? i:new Request(i,init)
			if (r.headers.get("Datastar-Request")!=="true" ||
				r.method=="GET"||r.method=="HEAD"||r.method=="OPTIONS"
			) return isReq ? o(r,init):o(r)
			const h=new Headers(r.headers)
			h.set("X-CSRF-Token",'`); err != nil {
				return err
			}
			if _, err := io.WriteString(w, csrfToken); err != nil {
				return err
			}
			if _, err := io.WriteString(w, `')
			return o(new Request(r,{...init,headers:h}))
		}
	</script>`); err != nil {
				return err
			}
		} else {
			s.logger.Warn("generated empty CSRF token",
				slog.String("user-id", sess.UserID),
				slog.Time("issued-at", sess.IssuedAt))
		}
	}
	if _, err := io.WriteString(w, "</head><body "); err != nil {
		return err
	}
	if writeBodyAttrs != nil {
		writeBodyAttrs(w)
	}
	if _, err := io.WriteString(w, ">"); err != nil {
		return err
	}
	if err := body.Render(r.Context(), w); err != nil {
		return err
	}
	_, err = io.WriteString(w, "</body></html>")
	return err
}

func (s *Server) handleStreamRequest(
	w http.ResponseWriter, r *http.Request, sessKey string, sess app.Session,
	subjects []string,
	fn func(
		sse *datastar.ServerSentEventGenerator,
		ch <-chan msgbroker.Message,
	),
) {
	if !s.checkIsDSReq(w, r) {
		return
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())
	mSSEConnections.Inc()
	defer mSSEConnections.Dec()
	start := time.Now()

	ctx := r.Context()
	sub, err := s.messageBroker.Subscribe(ctx, s.messageBrokerMetrics, subjects...)
	if err != nil {
		s.httpErrIntern(w, r, sse, "subscribing to message broker", err)
		return
	}

	subC := sub.C()
	sessionClosed := make(chan struct{})

	if sess.UserID != "" {
		ctx, cancel := context.WithCancel(ctx)
		defer cancel()
		if err := s.sessionManager.NotifyClosed(ctx, sessKey, func() {
			close(sessionClosed)
		}); err != nil {
			s.httpErrIntern(w, r, sse, "setting up session closure watcher", err)
			return
		}
	}

	go func() {
		// Close the subscription when the request is canceled or the session is closed.
		select {
		case <-sessionClosed:
			mSSEDisconnects.WithLabelValues("close").Inc()
		case <-r.Context().Done():
			mSSEDisconnects.WithLabelValues("client").Inc()
		case <-s.shutdownCh:
			mSSEDisconnects.WithLabelValues("shutdown").Inc()
		}
		mSSEConnectionDuration.Observe(time.Since(start).Seconds())
		sub.Close()
	}()

	fn(sse, subC)
}

func (s *Server) logErr(msg string, err error) {
	s.logger.Error(msg, slog.Any("err", err))
}

func (s *Server) httpErrBad(w http.ResponseWriter, msg string, err error) {
	s.logger.Debug("bad request", slog.String("cause", msg), slog.Any("err", err))
	http.Error(w, msg, http.StatusBadRequest)
}
