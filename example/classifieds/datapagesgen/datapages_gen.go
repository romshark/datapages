// Generated by github.com/romshark/datapages. DO NOT EDIT.

// Package datapagesgen is generated by datapages.
package datapagesgen

import (
	"bytes"
	"context"
	"crypto/rand"
	"crypto/subtle"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"hash"
	"io"
	"iter"
	"log/slog"
	"net"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/romshark/datapages/example/classifieds/app"

	"github.com/a-h/templ"
	"github.com/nats-io/nats.go"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/starfederation/datastar-go/datastar"
	"golang.org/x/sync/errgroup"
)

const (
	DefaultHTTPReadTimeout       = 30 * time.Second
	DefaultHTTPReadHeaderTimeout = 5 * time.Second
	DefaultHTTPWriteTimeout      = 0 // SSE needs this disabled.
	DefaultHTTPIdleTimeout       = 60 * time.Second
	DefaultHTTPMaxHeaderBytes    = 1 << 20 // 1 MB
)

// IsDevMode returns true when in the development environment.
// Returns false for production environments.
func IsDevMode() bool { return os.Getenv("TEMPL_DEV_MODE") != "" }

// MessageBroker is a common interface for message brokers.
type MessageBroker interface {
	// Subscribe creates a new subscription to a subject/stream.
	Subscribe(
		ctx context.Context, subjects ...string,
	) (MessageBrokerSubscription, error)

	// Publish sends a message to a subject (non-blocking)
	Publish(ctx context.Context, subject string, data []byte) error
}

// MessageBrokerSubscription represents an active message broker subscription.
type MessageBrokerSubscription interface {
	// C returns the channel to receive messages.
	C() <-chan Message

	// Close closes and removes the subscription.
	Close()
}

// Message represents a received message
type Message struct {
	Subject string
	Data    []byte
}

// ServerOption is a functional option for configuring Server
type ServerOption func(*Server) error

// WithMiddleware adds a custom middleware.
func WithMiddleware(middleware func(http.Handler) http.Handler) ServerOption {
	return func(s *Server) error {
		s.middleware = append(s.middleware, middleware)
		return nil
	}
}

// WithLogger sets a custom error logger.
// Consider setting level DEBUG when IsDevMode() returns true.
func WithLogger(l *slog.Logger) ServerOption {
	return func(s *Server) error {
		s.logger = l
		return nil
	}
}

// WithHTTPServer sets a custom HTTP server.
// The Addr and Handler fields are always overwritten.
func WithHTTPServer(server *http.Server) ServerOption {
	return func(s *Server) error {
		s.httpServer = server
		return nil
	}
}

// WithStaticFS sets a custom filesystem for serving static files at the
// specified URL path. If not provided, static file serving is disabled.
//
//	// This will serve files at URL path "/static/*" from directory "./assets".
//	subFS, err := fs.Sub(embedFS, "assets")
//	if err != nil { return err }
//	fs := http.FS(subFS)
//	//...
//	WithStaticFS("/static/", fs, nil)
//
// You may also optionally provide fsDev to use another filesystem for
// development environments. If fsDev it automatically falls back to fsProd.
// fsDev always serves static files with caching disabled.
func WithStaticFS(urlPath string, fsProd, fsDev http.FileSystem) ServerOption {
	return func(s *Server) error {
		if urlPath == "" || urlPath[0] != '/' {
			return fmt.Errorf("static urlPath must start with '/': %q", urlPath)
		}
		if !strings.HasSuffix(urlPath, "/") {
			urlPath += "/"
		}

		s.staticFS = fsProd
		if IsDevMode() && fsDev != nil {
			s.staticFS = fsDev
		}
		s.staticURLPath = urlPath
		return nil
	}
}

func devNoCache(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Cache-Control", "no-store, max-age=0")
		w.Header().Set("Pragma", "no-cache")
		w.Header().Set("Expires", "0")
		next.ServeHTTP(w, r)
	})
}

// WithMessageBrokerNATS sets the default message broker.
// By default, an in-memory single-proccess broker implementation is used.
func WithMessageBrokerNATS(conn *nats.Conn, conf MessageBrokerNATSConfig) ServerOption {
	return func(s *Server) error {
		b, err := newMessageBrokerNATS(conn, conf)
		if err != nil {
			return fmt.Errorf("initializing NATS message broker: %w", err)
		}
		s.messageBroker = b
		return nil
	}
}

// WithMessageBroker sets a custom message broker.
// By default, an in-memory single-proccess broker implementation is used.
func WithMessageBroker(b MessageBroker) ServerOption {
	return func(s *Server) error {
		s.messageBroker = b
		return nil
	}
}

type CSRFConfig struct {
	Secret []byte

	// DevBypassToken, if non-empty, is accepted as a valid
	// CSRF token for any session. Use this only in development
	// to allow tools like k6 to exercise POST endpoints.
	DevBypassToken string
}

// WithCSRFProtection enables Cross-Site-Request-Forgery protection on
// POST/PUT/PATCH/DELETE action endpoints. By default CSRF protection is disabled
// but will log a warning during server initialization time.
func WithCSRFProtection(conf CSRFConfig) ServerOption {
	return func(s *Server) error {
		if len(conf.Secret) < 1 {
			return errors.New("empty CSRF secret")
		}
		if conf.DevBypassToken != "" && !IsDevMode() {
			return errors.New("CSRF dev bypass token must not be set in non-dev mode")
		}
		s.csrfConf = &conf
		return nil
	}
}

// datapagesgen/server.go (generated)

// WithPrometheus starts a dedicated HTTP server exposing /metrics.
// Example host address: "127.0.0.1:9091" or ":9091".
func WithPrometheus(conf PrometheusConfig) ServerOption {
	return func(s *Server) error {
		if conf.Host == "" {
			return errors.New("prometheus host address must not be empty")
		}

		// Defaults
		if conf.Registerer == nil {
			conf.Registerer = prometheus.DefaultRegisterer
		}
		if conf.Gatherer == nil {
			conf.Gatherer = prometheus.DefaultGatherer
		}

		// Register built-in metrics on the configured registerer exactly once.
		registerPrometheusMetricsOnce.Do(func() {
			registerMetricsWith(conf.Registerer)
		})

		// Register user-defined collectors.
		for _, c := range conf.Collectors {
			conf.Registerer.MustRegister(c)
		}

		var h http.Handler
		if conf.Handler != nil {
			h = conf.Handler
		} else {
			h = promhttp.HandlerFor(conf.Gatherer, promhttp.HandlerOpts{})
		}

		mux := http.NewServeMux()
		mux.Handle("/metrics", h)

		s.metricsServer = &http.Server{
			Addr:    conf.Host,
			Handler: mux,
		}
		return nil
	}
}

type PrometheusConfig struct {
	Host       string
	Registerer prometheus.Registerer  // Optional, default: prometheus.DefaultRegisterer
	Gatherer   prometheus.Gatherer    // Optional, default: prometheus.DefaultGatherer
	Handler    http.Handler           // Optional override
	Collectors []prometheus.Collector // User-defined metrics to register
}

var registerPrometheusMetricsOnce sync.Once

func (s *Server) listenAndServe(
	ctx context.Context,
	listenAndServe func() error,
) error {
	ctx, cancel := context.WithCancel(ctx)
	s.runCancel = cancel

	if s.csrfConf == nil {
		s.logger.Warn("CSRF protection disabled")
	}

	g, ctx := errgroup.WithContext(ctx)

	// Main frontend server
	g.Go(func() error {
		if err := listenAndServe(); err != nil &&
			!errors.Is(err, http.ErrServerClosed) {
			return err
		}
		return nil
	})

	// Metrics server
	if s.metricsServer != nil {
		s.metricsServer.BaseContext = func(net.Listener) context.Context {
			return ctx
		}
		g.Go(func() error {
			err := s.metricsServer.ListenAndServe()
			if err != nil && !errors.Is(err, http.ErrServerClosed) {
				return fmt.Errorf("metrics server failed: %w", err)
			}
			return nil
		})
	}

	// Coordinated shutdown
	g.Go(func() error {
		<-ctx.Done()

		shutdownCtx, cancel := context.WithTimeout(
			context.Background(),
			10*time.Second,
		)
		defer cancel()

		_ = s.Shutdown(shutdownCtx)
		return nil
	})

	return g.Wait()
}

// ListenAndServe starts the main HTTP server and, if configured, a dedicated
// Prometheus metrics server.
//
// Both servers run concurrently and share the same lifecycle.
// If either server fails to start or exits unexpectedly, the other is
// shut down and the error is returned.
//
// The provided context controls graceful shutdown for both servers.
func (s *Server) ListenAndServe(
	ctx context.Context,
	addr string,
) error {
	s.httpServer.Addr = addr
	s.enabledTLS = false
	return s.listenAndServe(ctx, func() error {
		s.logger.Info("listening HTTP", slog.String("addr", addr))
		return s.httpServer.ListenAndServe()
	})
}

// ListenAndServeTLS acts identically to ListenAndServe,
// except that it expects HTTPS connections.
func (s *Server) ListenAndServeTLS(
	ctx context.Context,
	addr, certFile, keyFile string,
) error {
	s.httpServer.Addr = addr
	s.enabledTLS = true
	return s.listenAndServe(ctx, func() error {
		s.logger.Info("listening HTTP",
			slog.String("addr", addr),
			slog.String("tls.cert", certFile),
			slog.String("tls.key", keyFile))
		return s.httpServer.ListenAndServeTLS(certFile, keyFile)
	})
}

// Shutdown gracefully shuts down all server components,
// including the main HTTP server and the Prometheus metrics server.
func (s *Server) Shutdown(ctx context.Context) error {
	s.shutdownOnce.Do(func() {
		s.logger.Info("server shutdown initiated")
		if s.runCancel != nil {
			s.runCancel()
		}
		close(s.shutdownCh)
	})
	var errs []error
	if s.metricsServer != nil {
		if err := s.metricsServer.Shutdown(ctx); err != nil {
			errs = append(errs, err)
		}
	}
	if err := s.httpServer.Shutdown(ctx); err != nil {
		errs = append(errs, err)
	}
	return errors.Join(errs...)
}

type csrfGenerationContext struct {
	hmac         hash.Hash
	decodedToken []byte
	issuedAtHex  []byte
	base         []byte
	expectedBase []byte
	mask         []byte
	out          []byte
}

func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Build handler chain from middleware
	handler := http.Handler(s.mux)

	// Normalize trailing slashes: ensure all paths end with /
	// except for static file paths

	if p := r.URL.Path; p != "/" && !strings.HasSuffix(p, "/") {
		// Skip normalization for static file paths
		if s.staticURLPath == "" || !strings.HasPrefix(p, s.staticURLPath) {
			// Add trailing slash for non-static paths
			r.URL.Path = p + "/"
			// Update the raw path as well if it exists
			if r.URL.RawPath != "" {
				r.URL.RawPath = r.URL.RawPath + "/"
			}
		}
	}

	// Apply middleware in reverse order so they execute in the order they were added
	for _, h := range s.middleware {
		handler = h(handler)
	}

	handler.ServeHTTP(w, r)
}

func isDSReq(r *http.Request) bool {
	return r.Header.Get("Datastar-Request") == "true"
}

func (s *Server) checkIsDSReq(w http.ResponseWriter, r *http.Request) (ok bool) {
	if !isDSReq(r) {
		s.logger.Debug("not a datastar request",
			slog.Any("method", r.Method),
			slog.String("path", r.URL.Path))
		http.Error(w, http.StatusText(http.StatusNotAcceptable), http.StatusNotAcceptable)
		return false
	}
	return true
}

func (s *Server) checkCSRF(
	w http.ResponseWriter, r *http.Request, sess app.Session,
) (ok bool) {
	if sess.UserID == "" ||
		r.Method == http.MethodGet ||
		r.Method == http.MethodOptions ||
		r.Method == http.MethodHead ||
		s.csrfConf == nil {
		return true
	}
	t := r.Header.Get("X-CSRF-Token")
	if t == "" {
		http.Error(
			w,
			http.StatusText(http.StatusForbidden),
			http.StatusForbidden,
		)
		return false
	}
	if s.csrfConf.DevBypassToken != "" &&
		t == s.csrfConf.DevBypassToken {
		return true
	}
	if !s.validateCSRFToken(sess.UserID, sess.IssuedAt, t) {
		http.Error(
			w,
			http.StatusText(http.StatusForbidden),
			http.StatusForbidden,
		)
		return false
	}
	return true
}

func (s *Server) writeHTML(
	w http.ResponseWriter,
	r *http.Request,
	sess app.Session,
	headGeneric, head, body templ.Component,
	writeBodyAttrs func(w http.ResponseWriter),
) error {
	_, err := io.WriteString(w, `<!DOCTYPE html><html><head><meta charset="UTF-8"/>
		<script type="module" src="/static/ds.min.js"></script>`)
	if err != nil {
		return err
	}
	if headGeneric != nil {
		if err := headGeneric.Render(r.Context(), w); err != nil {
			return err
		}
	}
	if head != nil {
		if err := head.Render(r.Context(), w); err != nil {
			return err
		}
	}
	if s.csrfConf != nil && sess.UserID != "" {
		csrfToken := s.generateCSRFToken(sess.UserID, sess.IssuedAt)
		if csrfToken != "" {
			// Write the fetch X-CSRF-Token header injector.
			if _, err := io.WriteString(w, `
	<script type="module">
		const o = globalThis.fetch.bind(globalThis)
		globalThis.fetch=(i,init={}) => {
			const isReq=i instanceof Request
			const r=isReq ? i:new Request(i,init)
			if (r.headers.get("Datastar-Request")!=="true" ||
				r.method=="GET"||r.method=="HEAD"||r.method=="OPTIONS"
			) return isReq ? o(r,init):o(r)
			const h=new Headers(r.headers)
			h.set("X-CSRF-Token",'`); err != nil {
				return err
			}
			if _, err := io.WriteString(w, csrfToken); err != nil {
				return err
			}
			if _, err := io.WriteString(w, `')
			return o(new Request(r,{...init,headers:h}))
		}
	</script>`); err != nil {
				return err
			}
		} else {
			s.logger.Warn("generated empty CSRF token",
				slog.String("user-id", sess.UserID),
				slog.Time("issued-at", sess.IssuedAt))
		}
	}
	if _, err := io.WriteString(w, "</head><body "); err != nil {
		return err
	}
	if writeBodyAttrs != nil {
		writeBodyAttrs(w)
	}
	if _, err := io.WriteString(w, ">"); err != nil {
		return err
	}
	if err := body.Render(r.Context(), w); err != nil {
		return err
	}
	_, err = io.WriteString(w, "</body></html>")
	return err
}

func (s *Server) handleStreamRequest(
	w http.ResponseWriter, r *http.Request, sessKey string, sess app.Session,
	subjects []string,
	fn func(
		sse *datastar.ServerSentEventGenerator,
		ch <-chan Message,
	),
) {
	if !s.checkIsDSReq(w, r) {
		return
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())
	mSSEConnections.Inc()
	defer mSSEConnections.Dec()
	start := time.Now()

	ctx := r.Context()
	sub, err := s.messageBroker.Subscribe(ctx, subjects...)
	if err != nil {
		s.httpErrIntern(w, r, sse, "subscribing to message broker", err)
		return
	}

	subC := sub.C()
	sessionClosed := make(chan struct{})

	if sess.UserID != "" {
		ctx, cancel := context.WithCancel(ctx)
		defer cancel()
		s.sessionManager.NotifyClosed(ctx, sessKey, func() {
			close(sessionClosed)
		})
	}

	go func() {
		// Close the subscription when the request is canceled or the session is closed.
		select {
		case <-sessionClosed:
			mSSEDisconnects.WithLabelValues("close").Inc()
		case <-r.Context().Done():
			mSSEDisconnects.WithLabelValues("client").Inc()
		case <-s.shutdownCh:
			mSSEDisconnects.WithLabelValues("shutdown").Inc()
		}
		mSSEConnectionDuration.Observe(time.Since(start).Seconds())
		sub.Close()
	}()

	fn(sse, subC)
}

func (s *Server) logErr(msg string, err error) {
	s.logger.Error(msg, slog.Any("err", err))
}

func (s *Server) httpErrBad(w http.ResponseWriter, msg string, err error) {
	s.logger.Debug("bad request", slog.String("cause", msg), slog.Any("err", err))
	http.Error(w, msg, http.StatusBadRequest)
}

// --- CSRF ---

// withNewCSRFCtx derives a stable, per-session base secret value in the context.
func (s *Server) withNewCSRFCtx(
	userID string, sessIssuedAtUnix int64,
	withContext func(*csrfGenerationContext),
) {
	cgc := s.csrfHMACPool.Get().(*csrfGenerationContext)
	defer s.csrfHMACPool.Put(cgc)

	cgc.hmac.Reset()
	// Ensures the CSRF token is only valid for this user.
	_, _ = cgc.hmac.Write([]byte(userID))
	// Separator avoids ambiguity ("ab"+"12" vs "a"+"b12").
	_, _ = cgc.hmac.Write([]byte{0})
	// Bind token to a specific session preventing reuse across re-authentication.
	cgc.issuedAtHex = strconv.AppendInt(cgc.issuedAtHex[:0], sessIssuedAtUnix, 16)
	_, _ = cgc.hmac.Write(cgc.issuedAtHex)

	cgc.base = cgc.hmac.Sum(cgc.base[:0])
	withContext(cgc)
}

// generateCSRFToken returns the value sent to the browser.
// This uses the same masking technique as gorilla/csrf to prevent BREACH attacks:
//   - A random mask is generated per response.
//   - The real token is XORed with the mask.
//   - The mask is prepended so the server can reverse it.
func (s *Server) generateCSRFToken(userID string, sessIssuedAt time.Time) (t string) {
	u := sessIssuedAt.Unix()
	if u < 0 {
		return ""
	}
	s.withNewCSRFCtx(userID, u, func(cgc *csrfGenerationContext) {
		if _, err := rand.Read(cgc.mask); err != nil {
			panic(err) // rand.Read should never fail on a healthy system.
		}

		// [ mask | masked_token ]
		copy(cgc.out, cgc.mask)

		// XOR hides the real token while remaining reversible
		for i := range 32 {
			cgc.out[32+i] = cgc.base[i] ^ cgc.mask[i]
		}
		t = base64.RawURLEncoding.EncodeToString(cgc.out)
	})
	return t
}

// validateCSRFToken verifies a client-supplied token.
func (s *Server) validateCSRFToken(
	userID string, sessIssuedAt time.Time, token string,
) (ok bool) {
	u := sessIssuedAt.Unix()
	if len(token) != 86 || u < 0 {
		return false
	}
	s.withNewCSRFCtx(userID, u, func(cgc *csrfGenerationContext) {
		n, err := base64.RawURLEncoding.Decode(cgc.decodedToken, []byte(token))
		if err != nil || n != 64 {
			ok = false
			return
		}

		// [ mask | masked_token ]
		mask, enc := cgc.decodedToken[:32], cgc.decodedToken[32:]
		// Reverse XOR to recover the real token
		for i := range 32 {
			cgc.expectedBase[i] = enc[i] ^ mask[i]
		}
		// Recompute what the token SHOULD be for this session and compare.
		ok = subtle.ConstantTimeCompare(cgc.expectedBase, cgc.base) == 1
	})
	return ok
}

// --- MESSAGE BROKER: NATS ---

// MessageBrokerChanBuffer allows to decouple publisher/NATS callback from the consumer.
// Buffer size should be enough to absorb short bursts without blocking delivery,
// while bounding memory and ensuring slow consumers drop messages instead of
// backpressuring producers.
var MessageBrokerChanBuffer = 16

type MessageBrokerNATSConfig struct {
	StreamConfig *nats.StreamConfig
}

type messageBrokerNATS struct {
	nc *nats.Conn
	js nats.JetStreamContext
}

type natsSub struct {
	ch    chan Message
	subs  []*nats.Subscription
	close func()
}

func newMessageBrokerNATS(
	nc *nats.Conn, conf MessageBrokerNATSConfig,
) (*messageBrokerNATS, error) {
	js, err := nc.JetStream()
	if err != nil {
		return nil, err
	}

	if conf.StreamConfig == nil {
		conf.StreamConfig = new(nats.StreamConfig)
	}
	if conf.StreamConfig.Description == "" {
		conf.StreamConfig.Description = "stream was automatically created by datapages"
	}
	conf.StreamConfig.Subjects = MessageBrokerStreamSubjects()

	_, err = js.AddStream(conf.StreamConfig)
	if err != nil && !errors.Is(err, nats.ErrStreamNameAlreadyInUse) {
		return nil, err
	}

	return &messageBrokerNATS{nc: nc, js: js}, nil
}

func (b *messageBrokerNATS) Publish(
	ctx context.Context,
	subject string,
	data []byte,
) error {
	_, err := b.js.Publish(subject, data, nats.Context(ctx))
	if err == nil {
		mBrokerEventPublishes.WithLabelValues(brokerSubjectKind(subject)).Inc()
	}
	return err
}

func (b *messageBrokerNATS) Subscribe(
	_ context.Context, subjects ...string,
) (MessageBrokerSubscription, error) {
	ch := make(chan Message, MessageBrokerChanBuffer)
	subs := make([]*nats.Subscription, 0, len(subjects))

	var (
		lock     sync.Mutex
		closing  bool
		inflight sync.WaitGroup
		once     sync.Once
	)

	closeAll := func() {
		once.Do(func() {
			// After this, no callback can call wg.Add(1).
			lock.Lock()
			closing = true
			lock.Unlock()
			// Stop NATS deliveries.
			for _, s := range subs {
				_ = s.Unsubscribe()
			}
			// Wait until all callbacks that already registered complete.
			inflight.Wait()
			close(ch)
		})
	}

	for _, subject := range subjects {
		sub, err := b.nc.Subscribe(subject, func(m *nats.Msg) {
			// Registration is serialized with closeAll() so Add never races with Wait.
			lock.Lock()
			if closing {
				lock.Unlock()
				return
			}
			// Add must be done under lock to prevent it from racing with wg.Wait.
			// WaitGroup requires that no new Add happens once Wait may be running.
			inflight.Add(1)
			lock.Unlock()

			defer inflight.Done()

			select {
			case ch <- Message{
				Subject: m.Subject,
				Data:    bytes.Clone(m.Data),
			}:
			default: // drop if subscriber is slow
				mBrokerDeliveriesDropped.WithLabelValues("nats").Inc()
			}
		})
		if err != nil {
			// Undo already-created subscriptions safely (no send-to-closed-ch races).
			closeAll()
			return nil, err
		}
		subs = append(subs, sub)
	}

	ns := &natsSub{
		ch:   ch,
		subs: subs,
	}
	ns.close = closeAll
	return ns, nil
}

func (s *natsSub) C() <-chan Message {
	return s.ch
}

func (s *natsSub) Close() {
	if s.close == nil {
		return
	}
	s.close()
	s.close = nil // Prevent double-close
}

// --- MESSAGE BROKER: IN-MEM ---

type messageBrokerMem struct {
	lock sync.RWMutex
	subs map[string]map[*memSub]struct{}
}

type memSub struct {
	ch      chan Message
	topics  []string
	broker  *messageBrokerMem
	closed  bool
	closeMu sync.Mutex
}

func newMessageBrokerMem() *messageBrokerMem {
	return &messageBrokerMem{
		subs: make(map[string]map[*memSub]struct{}),
	}
}

func (b *messageBrokerMem) Close() error {
	return nil
}

func (b *messageBrokerMem) Publish(
	ctx context.Context,
	subject string,
	data []byte,
) error {
	b.lock.RLock()
	defer b.lock.RUnlock()
	subs := b.subs[subject]

	if len(subs) == 0 {
		return nil
	}

	msg := Message{
		Subject: subject,
		Data:    bytes.Clone(data),
	}
	mBrokerEventPublishes.WithLabelValues(brokerSubjectKind(subject)).Inc()

	for sub := range subs {
		select {
		case sub.ch <- msg:
		default: // drop if subscriber is slow (matches NATS core semantics)
			mBrokerDeliveriesDropped.WithLabelValues("mem").Inc()
		}
	}

	return nil
}

func (b *messageBrokerMem) Subscribe(
	ctx context.Context,
	subjects ...string,
) (MessageBrokerSubscription, error) {
	sub := &memSub{
		ch:     make(chan Message, MessageBrokerChanBuffer),
		topics: subjects,
		broker: b,
	}

	b.lock.Lock()
	for _, subject := range subjects {
		m, ok := b.subs[subject]
		if !ok {
			m = make(map[*memSub]struct{})
			b.subs[subject] = m
		}
		m[sub] = struct{}{}
	}
	b.lock.Unlock()

	return sub, nil
}

func (s *memSub) C() <-chan Message {
	return s.ch
}

func (s *memSub) Close() {
	s.closeMu.Lock()
	defer s.closeMu.Unlock()

	if s.closed {
		return
	}
	s.closed = true

	b := s.broker
	b.lock.Lock()
	for _, subject := range s.topics {
		if m, ok := b.subs[subject]; ok {
			delete(m, s)
			if len(m) == 0 {
				delete(b.subs, subject)
			}
		}
	}
	b.lock.Unlock()

	close(s.ch)
}

// --- SESSION MANAGER ---

type SessionTokenGenerator interface {
	// Generates a cryptographically random session token.
	Generate() (string, error)
}

type SessionManager interface {
	// ReadSessionFromCookie returns the resolved session and
	// the raw authentication token. Returns ok=false if auth information is malformed
	// and therefore the cookie must be removed.
	ReadSessionFromCookie(c *http.Cookie) (session app.Session, token string, ok bool)

	// CreateSession creates a new session identified by a unique token.
	// The returned token will be put into HTTP-only cookies.
	CreateSession(ctx context.Context, session app.Session) (token string, err error)

	// NotifyClosed sets up a listener that calls fn when session with key is closed.
	// The listener shall be stopped once ctx is canceled.
	// If the session manager implementation doesn't support dynamic closure notification
	// then NotifyClosed is a no-op.
	NotifyClosed(ctx context.Context, key string, fn func())

	// CloseSession closes a session identified by token.
	// No-op and no error if that session doesn't exist.
	CloseSession(ctx context.Context, token string) error
}

// WithSessionManager sets a custom session manager.
func WithSessionManager(sm SessionManager) ServerOption {
	return func(s *Server) error {
		s.sessionManager = sm
		return nil
	}
}

// --- SESSION TOKEN GENERATOR: Default ---

// DefaultSessionTokenLength is the number of random bytes used to generate
// session tokens. 32 bytes provides 256 bits of entropy.
const DefaultSessionTokenLength = 32

// DefaultSessionTokenGenerator generates cryptographically secure session tokens.
type DefaultSessionTokenGenerator struct {
	// Length is the number of random bytes to generate.
	// Defaults to DefaultSessionTokenLength if zero.
	Length int
}

// Generate returns a new cryptographically random session token
// encoded as URL-safe base64 without padding.
func (g DefaultSessionTokenGenerator) Generate() (string, error) {
	length := g.Length
	if length <= 24 {
		length = DefaultSessionTokenLength
	}
	b := make([]byte, length)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	return base64.RawURLEncoding.EncodeToString(b), nil
}

// --- SESSION MANAGER: NATS KV ---

// NewSessionManagerNATSKV creates a new NATS KV-backed session manager.
func NewSessionManagerNATSKV(
	conn *nats.Conn,
	sessionTokenGenerator SessionTokenGenerator,
	conf ConfigSessionManagerNATSKV,
) (*SessionManagerNATSKV, error) {
	js, err := conn.JetStream()
	if err != nil {
		return nil, fmt.Errorf("creating JetStream context: %w", err)
	}

	bucketName := conf.BucketName
	if bucketName == "" {
		bucketName = DefaultSessionManagerNATSKVBucketName
	}

	kvConfig := nats.KeyValueConfig{
		Bucket:  bucketName,
		Storage: nats.MemoryStorage,
	}
	if conf.TTL > 0 {
		kvConfig.TTL = conf.TTL
	}

	kv, err := js.CreateKeyValue(&kvConfig)
	if err != nil {
		// If the bucket already exists, get it instead
		if errors.Is(err, nats.ErrStreamNameAlreadyInUse) {
			kv, err = js.KeyValue(bucketName)
			if err != nil {
				return nil, fmt.Errorf("getting existing KV bucket: %w", err)
			}
		} else {
			return nil, fmt.Errorf("creating KV bucket: %w", err)
		}
	}

	return &SessionManagerNATSKV{
		conf:                  conf,
		kv:                    kv,
		sessionTokenGenerator: sessionTokenGenerator,
	}, nil
}

// DefaultSessionManagerNATSKVBucketName is the default bucket name for the
// NATS KV Store based session manager.
const DefaultSessionManagerNATSKVBucketName = "SESSIONS"

type ConfigSessionManagerNATSKV struct {
	// BucketName is the name of the KV bucket to use for sessions.
	// Optional; defaults to DefaultSessionManagerNATSKVBucketName.
	BucketName string

	// TTL is the time-to-live for session entries in the KV store.
	// Optional; defaults to no expiration.
	TTL time.Duration
}

// sessionManagerNATSKVData is the internal representation of session data stored in KV.
type sessionManagerNATSKVData struct {
	UserID   string    `json:"user_id"`
	IssuedAt time.Time `json:"issued_at"`
}

type SessionManagerNATSKV struct {
	conf                  ConfigSessionManagerNATSKV
	kv                    nats.KeyValue
	sessionTokenGenerator SessionTokenGenerator
}

func (s *SessionManagerNATSKV) ReadSessionFromCookie(
	c *http.Cookie,
) (session app.Session, token string, ok bool) {
	token = c.Value
	if token == "" {
		return app.Session{}, "", false
	}

	// Retrieve session data from NATS KV using token as key
	entry, err := s.kv.Get(token)
	if err != nil {
		if errors.Is(err, nats.ErrKeyNotFound) {
			// Session doesn't exist or expired
			return app.Session{}, "", false
		}
		// Malformed or error - signal cookie removal
		return app.Session{}, "", false
	}

	var sess sessionManagerNATSKVData
	if err := json.Unmarshal(entry.Value(), &sess); err != nil {
		// Corrupted data - signal cookie removal
		return app.Session{}, "", false
	}

	return app.Session{
		UserID:   sess.UserID,
		IssuedAt: sess.IssuedAt,
	}, token, true
}

func (s *SessionManagerNATSKV) NotifyClosed(
	ctx context.Context, key string, fn func(),
) {
	// Watch for changes to the specific session key
	watcher, err := s.kv.Watch(key, nats.Context(ctx))
	if err != nil {
		// If we can't watch, just return without calling fn
		return
	}

	go func() {
		defer func() { _ = watcher.Stop() }()

		for {
			select {
			case <-ctx.Done():
				return
			case entry := <-watcher.Updates():
				if entry == nil {
					// Channel closed
					return
				}
				// Check if the key was deleted (Operation == KeyValueDelete)
				if entry.Operation() == nats.KeyValueDelete || entry.Operation() == nats.KeyValuePurge {
					fn()
					return
				}
			}
		}
	}()
}

// SaveSession stores a session in NATS KV.
// The key is structured as {userID}.{token} to enable efficient prefix-based lookups.
// Returns the full key to be used as the cookie value.
func (s *SessionManagerNATSKV) SaveSession(
	ctx context.Context, token string, sess app.Session,
) (key string, err error) {
	data := sessionManagerNATSKVData{
		UserID:   sess.UserID,
		IssuedAt: sess.IssuedAt,
	}

	payload, err := json.Marshal(data)
	if err != nil {
		return "", fmt.Errorf("marshaling session data: %w", err)
	}

	key = sess.UserID + "." + token
	_, err = s.kv.Put(key, payload)
	if err != nil {
		return "", fmt.Errorf("storing session in KV: %w", err)
	}

	return key, nil
}

// CreateSession creates a new session in NATS KV.
func (s *SessionManagerNATSKV) CreateSession(
	ctx context.Context, session app.Session,
) (token string, err error) {
	token, err = s.sessionTokenGenerator.Generate()
	if err != nil {
		return "", err
	}
	if _, err := s.SaveSession(ctx, token, session); err != nil {
		return "", err
	}
	return token, nil
}

// CloseSession deletes a session from NATS KV. Watchers will be triggered.
func (s *SessionManagerNATSKV) CloseSession(ctx context.Context, token string) error {
	return s.kv.Delete(token)
}

// CloseAllUserSessions closes all sessions for a given user.
// Uses prefix matching on keys structured as {userID}.{token}.
// Appends the tokens of the closed sessions to buffer.
func (s *SessionManagerNATSKV) CloseAllUserSessions(
	buffer []string, userID string,
) ([]string, error) {
	// Watch with prefix pattern to find all sessions for this user.
	// Watch() first delivers all existing matching keys, then nil to signal completion.
	watcher, err := s.kv.Watch(userID+".*", nats.IgnoreDeletes(), nats.MetaOnly())
	if err != nil {
		return nil, fmt.Errorf("watching user sessions: %w", err)
	}
	defer func() { _ = watcher.Stop() }()

	var errs []error
	for entry := range watcher.Updates() {
		if entry == nil {
			break // Initial enumeration complete
		}
		k := entry.Key()
		if err := s.kv.Delete(k); err != nil {
			errs = append(errs, fmt.Errorf("deleting session %q: %w", k, err))
		}
		buffer = append(buffer, k)
	}

	return buffer, errors.Join(errs...)
}

var ErrSessionManagerNATSKVNotFound = errors.New("session not found")

// Session retrieves a session by its key.
// Returns an error if the session doesn't exist or is corrupted.
func (s *SessionManagerNATSKV) Session(
	ctx context.Context, token string,
) (app.Session, error) {
	entry, err := s.kv.Get(token)
	if err != nil {
		if errors.Is(err, nats.ErrKeyNotFound) {
			return app.Session{}, ErrSessionManagerNATSKVNotFound
		}
		return app.Session{}, fmt.Errorf("getting session: %w", err)
	}

	var data sessionManagerNATSKVData
	if err := json.Unmarshal(entry.Value(), &data); err != nil {
		return app.Session{}, fmt.Errorf("unmarshaling session data: %w", err)
	}

	return app.Session{
		UserID:   data.UserID,
		IssuedAt: data.IssuedAt,
	}, nil
}

// UserSessions returns an iterator over all sessions for a given user.
// The iterator yields (key, session) pairs.
// If an error occurs during iteration, the iterator stops early.
func (s *SessionManagerNATSKV) UserSessions(
	userID string,
) iter.Seq2[string, app.Session] {
	return func(yield func(string, app.Session) bool) {
		watcher, err := s.kv.Watch(userID+".*", nats.IgnoreDeletes())
		if err != nil {
			return
		}
		defer func() { _ = watcher.Stop() }()

		for entry := range watcher.Updates() {
			if entry == nil {
				break // Initial enumeration complete
			}

			var data sessionManagerNATSKVData
			if err := json.Unmarshal(entry.Value(), &data); err != nil {
				continue // Skip corrupted entries
			}

			sess := app.Session{
				UserID:   data.UserID,
				IssuedAt: data.IssuedAt,
			}
			if !yield(entry.Key(), sess) {
				return
			}
		}
	}
}
