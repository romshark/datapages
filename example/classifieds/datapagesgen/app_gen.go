// Generated by github.com/romshark/datapages. DO NOT EDIT.

package datapagesgen

import (
	"bufio"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net"
	"net/http"
	"os"
	"slices"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/romshark/datapages/example/classifieds/app"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/starfederation/datastar-go/datastar"
)

type Server struct {
	shutdownCh    chan struct{} // Closed when shutting down.
	shutdownOnce  sync.Once
	runCancel     context.CancelFunc
	httpServer    *http.Server
	messageBroker MessageBroker
	app           *app.App
	mux           *http.ServeMux
	logger        *slog.Logger
	middleware    []func(http.Handler) http.Handler
	staticURLPath string
	staticFS      http.FileSystem
	enabledTLS    bool

	metricsServer         *http.Server
	authConf              *AuthConfig
	sessionTokenGenerator SessionTokenGenerator
	sessionManager        SessionManager
	csrfConf              *CSRFConfig
	csrfHMACPool          sync.Pool
}

// NewServer creates a new server instance.
// Supported options:
//
//   - WithMiddleware
//   - WithHTTPServer
//   - WithStaticFS
//   - WithMessageBroker
//   - WithMessageBrokerNATS
//   - WithCSRFProtection
//   - WithPrometheus
func NewServer(app *app.App, opts ...ServerOption) *Server {
	s := &Server{
		shutdownCh: make(chan struct{}),
		httpServer: &http.Server{
			// Time to read request headers + body
			ReadTimeout: DefaultHTTPReadTimeout,
			// Time to read just headers (helps prevent Slowloris attacks)
			ReadHeaderTimeout: DefaultHTTPReadHeaderTimeout,
			// Time to write response
			WriteTimeout: DefaultHTTPWriteTimeout,
			// Time to wait for next request when using keep-alive
			IdleTimeout:    DefaultHTTPIdleTimeout,
			MaxHeaderBytes: DefaultHTTPMaxHeaderBytes,
		},
		app:        app,
		mux:        http.NewServeMux(),
		middleware: []func(http.Handler) http.Handler{},
	}

	// Apply options
	for _, opt := range opts {
		if err := opt(s); err != nil {
			panic(fmt.Errorf("applying server option: %w", err))
		}
	}

	// Reverse handlers such that they're invoked in the order of definition.
	slices.Reverse(s.middleware)

	if s.metricsServer == nil {
		// package app is using prometheus metrics, hence WithPrometheus is required.
		panic("missing option WithPrometheus")
	}

	if s.sessionManager == nil {
		panic("missing SessionManager; provide a session manager using WithAuth")
	}
	if s.sessionTokenGenerator == nil {
		s.sessionTokenGenerator = DefaultSessionTokenGenerator{
			Length: DefaultSessionTokenLength,
		}
	}

	// Use defaults if not set.
	if s.logger == nil {
		opt := &slog.HandlerOptions{
			Level: slog.LevelInfo,
		}
		if IsDevMode() {
			opt.Level = slog.LevelDebug
		}
		s.logger = slog.New(slog.NewJSONHandler(os.Stderr, opt))
	}
	s.httpServer.Handler = s
	if s.httpServer.ErrorLog == nil {
		s.httpServer.ErrorLog = slog.NewLogLogger(
			slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{}),
			slog.LevelInfo,
		)
	}
	if s.messageBroker == nil {
		s.messageBroker = newMessageBrokerMem()
	}

	if s.metricsServer != nil {
		s.middleware = append(s.middleware, s.metricsMiddleware)
	}

	if s.csrfConf != nil {
		s.csrfHMACPool.New = func() any {
			return &csrfGenerationContext{
				hmac:         hmac.New(sha256.New, s.csrfConf.Secret),
				decodedToken: make([]byte, 64),
				issuedAtHex:  make([]byte, 16),
				base:         make([]byte, 32),
				expectedBase: make([]byte, 32),
				mask:         make([]byte, 32),
				out:          make([]byte, 64),
			}
		}
	}

	setupHandlers(s)
	if s.staticFS != nil {
		h := http.StripPrefix("/static/", http.FileServer(s.staticFS))
		if IsDevMode() {
			h = devNoCache(h)
		}
		s.mux.Handle("GET /static/", h)
	}

	return s
}

// --- Message Broker ---

const DefaultBodySizeLimit = 1024 * 1024 // 1 MiB

const (
	EvSubjMessagingSent           = "messaging.sent.*"
	EvSubjMessagingRead           = "messaging.read.*"
	EvSubjMessagingWriting        = "messaging.writing.*"
	EvSubjMessagingWritingStopped = "messaging.writing-stopped.*"
	EvSubjSessionsClosed          = "sessions.closed.*"

	// Public events:

	EvSubjPostArchived = "posts.archived"
)

const (
	EvSubjPrefMessagingSent           = "messaging.sent."
	EvSubjPrefMessagingRead           = "messaging.read."
	EvSubjPrefMessagingWriting        = "messaging.writing."
	EvSubjPrefMessagingWritingStopped = "messaging.writing-stopped."
	EvSubjPrefSessionsClosed          = "sessions.closed."
)

func MessageBrokerStreamSubjects() []string {
	return []string{
		EvSubjMessagingSent,
		EvSubjMessagingRead,
		EvSubjMessagingWriting,
		EvSubjMessagingWritingStopped,
		EvSubjPostArchived,
		EvSubjSessionsClosed,
	}
}

func evSubjPageIndex(userID string) []string {
	return []string{
		EvSubjPrefMessagingSent + userID,
		EvSubjPrefMessagingRead + userID,
	}
}

func evSubjPageMessages(userID string) []string {
	return []string{
		EvSubjPrefMessagingSent + userID,
		EvSubjPrefMessagingRead + userID,
		EvSubjPrefMessagingWriting + userID,
		EvSubjPrefMessagingWritingStopped + userID,
	}
}

func evSubjPagePost(userID string) []string {
	if userID == "" {
		return []string{
			EvSubjPostArchived,
		}
	}
	return []string{
		EvSubjPostArchived,
		EvSubjPrefMessagingSent + userID,
		EvSubjPrefMessagingRead + userID,
	}
}

func evSubjPageSearch(userID string) []string {
	return []string{
		EvSubjPrefMessagingSent + userID,
		EvSubjPrefMessagingRead + userID,
	}
}

func evSubjPageSettings(userID string) []string {
	return []string{
		EvSubjPrefMessagingSent + userID,
		EvSubjPrefMessagingRead + userID,
		EvSubjPrefSessionsClosed + userID,
	}
}

// --- Auth ---

const DefaultAuthSessionCookieName = "sessiontoken"

type AuthConfig struct {
	SessionManager SessionManager

	// SessionTokenGenerator is optional; defaults to DefaultSessionTokenGenerator
	SessionTokenGenerator SessionTokenGenerator

	// TokenCookie is optional; defaults to DefaultAuthSessionCookieName
	TokenCookie AuthSessionConfigTokenCookie

	// DisableHTTPOnly is optional; By default, httponly is enabled.
	DisableHTTPOnly bool
}

type AuthSessionConfigTokenCookie struct {
	// Name is optional; Default is DefaultAuthSessionCookieName
	Name string
	// Domain is optional; Not set by default.
	Domain string
}

// WithAuth sets session-based authentication configuration.
func WithAuth(o AuthConfig) ServerOption {
	return func(s *Server) error {
		if o.TokenCookie.Name == "" {
			o.TokenCookie.Name = DefaultAuthSessionCookieName
		}
		s.authConf = &o
		s.sessionTokenGenerator = o.SessionTokenGenerator
		s.sessionManager = o.SessionManager
		return nil
	}
}

func (s *Server) setSessionCookie(w http.ResponseWriter, value string) {
	cookie := http.Cookie{
		Name:     s.authConf.TokenCookie.Name,
		Value:    value,
		Path:     "/",
		Domain:   s.authConf.TokenCookie.Domain,
		HttpOnly: !s.authConf.DisableHTTPOnly,
		Secure:   s.enabledTLS,
		SameSite: http.SameSiteLaxMode,
	}
	if value == "" {
		cookie.MaxAge = -1
		cookie.Expires = time.Unix(0, 0)
	}
	http.SetCookie(w, &cookie)
}

func (s *Server) createSession(
	w http.ResponseWriter, r *http.Request, session app.Session,
) error {
	token, err := s.sessionManager.CreateSession(r.Context(), session)
	if err != nil {
		mSessionCreations.WithLabelValues("error").Inc()
		return err
	}
	mSessionCreations.WithLabelValues("success").Inc()
	s.setSessionCookie(w, session.UserID+"."+token)
	return nil
}

func (s *Server) closeSession(
	w http.ResponseWriter, r *http.Request,
	token string,
) error {
	if err := s.sessionManager.CloseSession(r.Context(), token); err != nil {
		mSessionClosures.WithLabelValues("error").Inc()
		return err
	}
	mSessionClosures.WithLabelValues("success").Inc()
	s.setSessionCookie(w, "")
	return nil
}

// authSess reads the session token from r and checks CSRF when necessary.
// If onClose != nil it will be closed once the session is closed.
func (s *Server) auth(
	w http.ResponseWriter, r *http.Request,
) (sess app.Session, token string, ok bool) {
	c, err := r.Cookie(s.authConf.TokenCookie.Name)
	if err != nil {
		if errors.Is(err, http.ErrNoCookie) {
			mSessionReads.WithLabelValues("none").Inc()
			return sess, "", true
		}
		return sess, "", false
	}

	sess, token, ok = s.sessionManager.ReadSessionFromCookie(c)
	if !ok {
		// Cookie is stale or malformed; clear it and continue as unauthenticated.
		mSessionReads.WithLabelValues("stale").Inc()
		s.setSessionCookie(w, "")
		return app.Session{}, "", true
	}

	mSessionReads.WithLabelValues("valid").Inc()

	if !s.checkCSRF(w, r, sess) {
		return sess, token, false
	}

	return sess, token, true
}

// --- Prometheus Metrics ---

// Datapages metrics
var (
	mHTTPRequestsTotal = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "datapages",
			Subsystem: "http",
			Name:      "requests_total",
			Help:      "Total HTTP requests",
		},
		[]string{"method", "path", "status"},
	)
	mHTTPRequestDuration = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Namespace: "datapages",
			Subsystem: "http",
			Name:      "request_duration_seconds",
			Help:      "HTTP request latency",
			Buckets:   prometheus.DefBuckets,
		},
		[]string{"method", "path"},
	)
	mInternalErrorsRecovered = prometheus.NewCounter(
		prometheus.CounterOpts{
			Namespace: "datapages",
			Name:      "internal_errors_recovered_total",
			Help:      "Internal errors recovered without HTTP failure",
		},
	)
	mInternalErrorsNotRecovered = prometheus.NewCounter(
		prometheus.CounterOpts{
			Namespace: "datapages",
			Name:      "internal_errors_not_recovered_total",
			Help: "Internal errors that could not be recovered and " +
				"resulted in an HTTP error response",
		},
	)
	mInFlightRequests = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Namespace: "datapages",
			Subsystem: "http",
			Name:      "in_flight_requests",
			Help:      "Current in-flight HTTP requests",
		},
	)

	mSSEConnections = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Namespace: "datapages",
			Subsystem: "http",
			Name:      "sse_connections",
			Help:      "Active SSE connections",
		},
	)

	// By-kind (low-cardinality) publish counters.
	// Useful because subjects include user IDs (high-cardinality),
	// so we collapse to event kinds.
	mBrokerEventPublishes = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "datapages",
			Subsystem: "event_broker",
			Name:      "publishes_by_kind_total",
			Help:      "Published events by kind (low-cardinality)",
		},
		[]string{"kind"},
	)

	// Dropped broker deliveries (slow consumers).
	mBrokerDeliveriesDropped = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "datapages",
			Subsystem: "event_broker",
			Name:      "deliveries_dropped_total",
			Help:      "Dropped broker deliveries due to slow consumers",
		},
		[]string{"broker"}, // "nats" | "mem"
	)

	// SSE connection lifetime + disconnect reasons.
	mSSEConnectionDuration = prometheus.NewHistogram(
		prometheus.HistogramOpts{
			Namespace: "datapages",
			Subsystem: "sse",
			Name:      "connection_duration_seconds",
			Help:      "SSE connection lifetime in seconds",
			Buckets:   prometheus.DefBuckets,
		},
	)

	mSSEDisconnects = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "datapages",
			Subsystem: "sse",
			Name:      "disconnects_total",
			Help:      "SSE disconnects by reason",
		},
		[]string{"reason"}, // "ttl" | "client" | "shutdown"
	)

	mSessionCreations = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "datapages",
			Subsystem: "session",
			Name:      "creations_total",
			Help:      "Session creations",
		},
		[]string{"result"}, // "success" | "error"
	)
	mSessionClosures = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "datapages",
			Subsystem: "session",
			Name:      "closures_total",
			Help:      "Session closures",
		},
		[]string{"result"}, // "success" | "error"
	)
	mSessionReads = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace: "datapages",
			Subsystem: "session",
			Name:      "reads_total",
			Help:      "Session reads from cookie",
		},
		[]string{"result"}, // "valid" | "none" | "stale"
	)
)

// registerMetricsWith registers the built-in datapages metrics on r.
func registerMetricsWith(r prometheus.Registerer) {
	r.MustRegister(
		mHTTPRequestsTotal,
		mHTTPRequestDuration,
		mInFlightRequests,
		mInternalErrorsRecovered,
		mInternalErrorsNotRecovered,
		mSSEConnections,
		mSSEConnectionDuration,
		mSSEDisconnects,
		mBrokerEventPublishes,
		mBrokerDeliveriesDropped,
		mSessionCreations,
		mSessionClosures,
		mSessionReads,
	)
}

// brokerSubjectKind collapses high-cardinality subjects (per-user) into stable kinds.
func brokerSubjectKind(subject string) string {
	switch {
	case strings.HasPrefix(subject, EvSubjPrefMessagingSent):
		return "messaging.sent"
	case strings.HasPrefix(subject, EvSubjPrefMessagingRead):
		return "messaging.read"
	case strings.HasPrefix(subject, EvSubjPrefMessagingWriting):
		return "messaging.writing"
	case strings.HasPrefix(subject, EvSubjPrefMessagingWritingStopped):
		return "messaging.writing-stopped"
	case subject == EvSubjPostArchived:
		return "posts.archived"
	case strings.HasPrefix(subject, EvSubjPrefSessionsClosed):
		return "sessions.closed"
	default:
		return "unknown"
	}
}

type statusRW struct {
	http.ResponseWriter
	status int
}

func (w *statusRW) WriteHeader(code int) {
	w.status = code
	w.ResponseWriter.WriteHeader(code)
}

func (w *statusRW) Flush() {
	if f, ok := w.ResponseWriter.(http.Flusher); ok {
		f.Flush()
	}
}

func (w *statusRW) Hijack() (net.Conn, *bufio.ReadWriter, error) {
	h, ok := w.ResponseWriter.(http.Hijacker)
	if !ok {
		return nil, nil, errors.New(
			"underlying ResponseWriter does not implement http.Hijacker",
		)
	}
	return h.Hijack()
}

func (w *statusRW) Push(target string, opts *http.PushOptions) error {
	p, ok := w.ResponseWriter.(http.Pusher)
	if !ok {
		return http.ErrNotSupported
	}
	return p.Push(target, opts)
}

// routeLabel returns a low-cardinality label for the route.
// Prefer r.Pattern (Go 1.22 ServeMux patterns) and fall back to the raw path.
func routeLabel(r *http.Request) string {
	if p := r.Pattern; p != "" {
		return p
	}
	return r.URL.Path
}

// metricsMiddleware must be the very first middleware in the chain (outermost),
// so it measures everything, including other middleware work.
func (s *Server) metricsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		mInFlightRequests.Inc()
		defer mInFlightRequests.Dec()

		rw := &statusRW{ResponseWriter: w, status: http.StatusOK}
		next.ServeHTTP(rw, r)

		path := routeLabel(r)
		mHTTPRequestsTotal.WithLabelValues(r.Method, path, strconv.Itoa(rw.status)).Inc()

		reqDur := time.Since(start).Seconds()
		mHTTPRequestDuration.WithLabelValues(r.Method, path).Observe(reqDur)
	})
}

// --- HTTP Handlers ---

func httpRedirect(w http.ResponseWriter, r *http.Request, target string, status int) (exit bool) {
	if target == "" {
		return false
	}

	if isDSReq(r) {
		// Force client-side navigation via JS for Datastar requests.
		w.Header().Set("Content-Type", "text/javascript; charset=utf-8")
		_, _ = fmt.Fprintf(w, "window.location = %q;", target)
		return true
	}

	switch status {
	case http.StatusMovedPermanently,
		http.StatusFound,
		http.StatusSeeOther,
		http.StatusTemporaryRedirect,
		http.StatusPermanentRedirect:
		// OK
	default:
		status = http.StatusFound
	}

	http.Redirect(w, r, target, status)
	return true
}

func setupHandlers(s *Server) {
	// Pages
	s.mux.HandleFunc(
		"GET /",
		s.handlePageIndexGET)
	s.mux.HandleFunc(
		"GET /_$/{$}",
		s.handlePageIndexGETStream)
	s.mux.HandleFunc(
		"POST /cause-500-internal-error/{$}",
		s.handlePOSTCause500)
	s.mux.HandleFunc(
		"POST /sign-out/{$}",
		s.handlePageSettingsPOSTSignOut)
	s.mux.HandleFunc(
		"GET /not-found/{$}",
		s.handlePageError404GET)
	s.mux.HandleFunc(
		"GET /whoops/{$}",
		s.handlePageError500GET)
	s.mux.HandleFunc(
		"GET /login/{$}",
		s.handlePageLoginGET)
	s.mux.HandleFunc(
		"POST /login/submit/{$}",
		s.handlePageLoginPOSTSubmit)
	s.mux.HandleFunc(
		"GET /settings/{$}",
		s.handlePageSettingsGET)
	s.mux.HandleFunc(
		"GET /settings/_$/{$}",
		s.handlePageSettingsGETStream)
	s.mux.HandleFunc(
		"POST /settings/save/{$}",
		s.handlePageSettingsPOSTSave)
	s.mux.HandleFunc(
		"POST /settings/close-session/{token}/{$}",
		s.handlePageSettingsPOSTCloseSession)
	s.mux.HandleFunc(
		"POST /settings/close-all-sessions/{$}",
		s.handlePageSettingsPOSTCloseAllSessions)
	s.mux.HandleFunc(
		"GET /messages/{$}",
		s.handlePageMessagesGET)
	s.mux.HandleFunc(
		"GET /messages/_$/{$}",
		s.handlePageMessagesGETStream)
	s.mux.HandleFunc(
		"POST /messages/read/{$}",
		s.handlePageMessagesPOSTRead)
	s.mux.HandleFunc(
		"POST /messages/writing/{$}",
		s.handlePageMessagesPOSTWriting)
	s.mux.HandleFunc(
		"POST /messages/writing-stopped/{$}",
		s.handlePageMessagesPOSTWritingStopped)
	s.mux.HandleFunc(
		"POST /messages/sendmessage/{$}",
		s.handlePageMessagesPOSTSendMessage)
	s.mux.HandleFunc(
		"GET /search/{$}",
		s.handlePageSearchGET)
	s.mux.HandleFunc(
		"GET /search/_$/{$}",
		s.handlePageSearchGETStream)
	s.mux.HandleFunc(
		"POST /search/paramchange/{$}",
		s.handlePageSearchPOSTParamChange)
	s.mux.HandleFunc(
		"GET /user/{name}/{$}",
		s.handlePageUserGET)
	s.mux.HandleFunc(
		"GET /my-posts/{$}",
		s.handlePageMyPostsGET)
	s.mux.HandleFunc(
		"GET /post/{slug}/{$}",
		s.handlePagePostGET)
	s.mux.HandleFunc(
		"GET /post/{slug}/_$/{$}",
		s.handlePagePostGETStream)
	s.mux.HandleFunc(
		"GET /post/{slug}/_$/anon/{$}",
		s.handlePagePostGETStreamAnon)
	s.mux.HandleFunc(
		"POST /post/{slug}/send-message/{$}",
		s.handlePagePostPOSTSendMessage)
}

func (s *Server) httpErrUnauth(w http.ResponseWriter) {
	const code = http.StatusUnauthorized
	http.Error(w, http.StatusText(code), code)
}

func (s *Server) httpErrIntern(
	w http.ResponseWriter, r *http.Request,
	sse *datastar.ServerSentEventGenerator, msg string, err error,
) {
	s.logErr(msg, err)
	if !isDSReq(r) {
		s.handlePageError500GET(w, r)
		return
	}
	if sse == nil {
		sse = datastar.NewSSE(w, r, datastar.WithCompression())
	}
	errRecover := s.app.Recover500(err, sse)
	if errRecover == nil {
		mInternalErrorsRecovered.Inc()
		return // Feedback delivered gracefully.
	}
	// Fallback to ugly 500
	mInternalErrorsNotRecovered.Inc()
	s.logger.Error("recovering 500",
		slog.Any("orig.msg", msg),
		slog.Any("orig.err", err),
		slog.Any("err", errRecover))
	const code = http.StatusInternalServerError
	http.Error(w, http.StatusText(code), code)
}

func (s *Server) render404(w http.ResponseWriter, r *http.Request) {
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}

	p := app.PageError404{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	body, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageError404.GET", err)
		return
	}

	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageError404", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) {
		writeBodyAttrOnVisibilityChange(w)
	}

	if err := s.writeHTML(
		w, r, app.Session{}, genericHead, nil, body, bodyAttrs,
	); err != nil {
		s.logErr("rendering PageError404", err)
		return
	}
}

func (s *Server) handlePOSTCause500(w http.ResponseWriter, r *http.Request) {
	if err := s.app.POSTCause500(r); err != nil {
		s.httpErrIntern(w, r, nil, "handling action App.POSTCause500", err)
	}
}

func (s *Server) handlePageSettingsPOSTCloseSession(
	w http.ResponseWriter, r *http.Request,
) {
	sess, sessToken, ok := s.auth(w, r)
	if !ok {
		return
	}

	var path struct {
		Token string `path:"token"`
	}
	path.Token = r.PathValue("token")

	dispatch := func(
		e1 app.EventSessionClosed,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventSessionClosed JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefSessionsClosed + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PageSettings{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	closeSession, redirect, err := p.POSTCloseSession(r, sessToken, sess, path, dispatch)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageUser.GET", err)
		return
	}
	if closeSession {
		if err := s.closeSession(w, r, sessToken); err != nil {
			s.httpErrIntern(w, r, nil, "removing session", err)
			return
		}
	}
	if httpRedirect(w, r, redirect, 0) {
		return
	}
}

func (s *Server) handlePageSettingsPOSTCloseAllSessions(
	w http.ResponseWriter, r *http.Request,
) {
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}

	dispatch := func(
		e1 app.EventSessionClosed,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventSessionClosed JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefSessionsClosed + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PageSettings{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	redirect, err := p.POSTCloseAllSessions(r, sess, dispatch)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling action App.POSTCloseAllSessions", err)
		return
	}
	if httpRedirect(w, r, redirect, 0) {
		return
	}
}

func (s *Server) handlePageError500GET(w http.ResponseWriter, r *http.Request) {
	p := app.PageError500{App: s.app}
	body, disableRefreshAfterHidden, err := p.GET(r)
	if err != nil {
		// Fall back to basic 500 error page.
		s.httpErrIntern(w, r, nil, "handling PageError500.GET", err)
		return
	}

	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageError500", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) {
		if !disableRefreshAfterHidden {
			writeBodyAttrOnVisibilityChange(w)
		}
	}

	if err := s.writeHTML(
		w, r, app.Session{}, genericHead, nil, body, bodyAttrs,
	); err != nil {
		s.logErr("rendering PageError500", err)
		return
	}
}

func (s *Server) handlePageIndexGET(w http.ResponseWriter, r *http.Request) {
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}

	if r.URL.Path != "/" {
		s.render404(w, r)
		return
	}

	p := app.PageIndex{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	body, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageIndex.GET", err)
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageIndex", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) {
		writeBodyAttrOnVisibilityChange(w)

		if sess.UserID != "" {
			_, _ = io.WriteString(w, `data-init="@get('/_$/')"`)
		}
	}

	if err := s.writeHTML(
		w, r, sess, genericHead, nil, body, bodyAttrs,
	); err != nil {
		s.logErr("rendering PageIndex", err)
		return
	}
}

func (s *Server) handlePageIndexGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, sessToken, ok := s.auth(w, r)
	if !ok {
		return
	}

	if sess.UserID == "" {
		http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
		return
	}

	p := app.PageIndex{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	s.handleStreamRequest(w, r, sessToken, sess, evSubjPageIndex(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(e, sse, sess); err != nil {
					s.logErr("handling PageIndex.Base.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingRead):
				var e app.EventMessagingRead
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingRead JSON", err)
					continue
				}
				if err := p.OnMessagingRead(e, sse, sess); err != nil {
					s.logErr("handling PageIndex.Base.OnMessagingRead", err)
				}
			}
		}
	})
}

func (s *Server) handlePageError404GET(w http.ResponseWriter, r *http.Request) {
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}

	p := app.PageError404{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	body, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageError404.GET", err)
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageError404", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) {
		writeBodyAttrOnVisibilityChange(w)
	}

	if err := s.writeHTML(
		w, r, sess, genericHead, nil, body, bodyAttrs,
	); err != nil {
		s.logErr("rendering PageError404", err)
		return
	}
}

func (s *Server) handlePageLoginGET(w http.ResponseWriter, r *http.Request) {
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}

	p := app.PageLogin{App: s.app}
	body, redirect, disableRefreshAfterHidden, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageLogin.GET", err)
		return
	}
	if httpRedirect(w, r, redirect, 0) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageLogin", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) {
		if !disableRefreshAfterHidden {
			writeBodyAttrOnVisibilityChange(w)
		}
	}

	if err := s.writeHTML(
		w, r, sess, genericHead, nil, body, bodyAttrs,
	); err != nil {
		s.logErr("rendering PageLogin", err)
		return
	}
}

func (s *Server) handlePageLoginPOSTSubmit(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}
	var signals struct {
		EmailOrUsername string `json:"emailorusername"`
		Password        string `json:"password"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "reading signals", err)
		return
	}

	p := app.PageLogin{App: s.app}
	body, redirect, redirectStatus, newSession, err := p.POSTSubmit(
		r, sess, signals,
	)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageLogin.POSTSubmit", err)
		return
	}
	if j := newSession; j.UserID != "" {
		if err := s.createSession(w, r, newSession); err != nil {
			s.httpErrIntern(w, r, nil, "creating session", err)
		}
	}
	if httpRedirect(w, r, redirect, redirectStatus) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageLogin.PostSubmit", err)
		return
	}
	if err := s.writeHTML(
		w, r, sess, genericHead, nil, body, nil,
	); err != nil {
		s.logErr("rendering response of PageLogin.POSTSubmit", err)
		return
	}
}

func (s *Server) handlePageSettingsGET(w http.ResponseWriter, r *http.Request) {
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}

	p := app.PageSettings{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	body, redirect, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageSettings.GET", err)
		return
	}
	if httpRedirect(w, r, redirect, 0) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageSettings", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) {
		writeBodyAttrOnVisibilityChange(w)

		if sess.UserID != "" {
			_, _ = io.WriteString(w, `data-init="@get('/settings/_$/')"`)
		}
	}

	if err := s.writeHTML(
		w, r, sess, genericHead, nil, body, bodyAttrs,
	); err != nil {
		s.logErr("rendering PageSettings", err)
		return
	}
}

func (s *Server) handlePageSettingsGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, sessToken, ok := s.auth(w, r)
	if !ok {
		return
	}

	if sess.UserID == "" {
		http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
		return
	}

	p := app.PageSettings{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	s.handleStreamRequest(w, r, sessToken, sess, evSubjPageSettings(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjPrefSessionsClosed):
				var e app.EventSessionClosed
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventSessionClosed JSON", err)
					continue
				}
				if err := p.OnSessionClosed(e, sse, sessToken, sess); err != nil {
					s.logErr("handling PageSettings.OnSessionClosed", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(e, sse, sess); err != nil {
					s.logErr("handling PageSettings.Base.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingRead):
				var e app.EventMessagingRead
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingRead JSON", err)
					continue
				}
				if err := p.OnMessagingRead(e, sse, sess); err != nil {
					s.logErr("handling PageSettings.Base.OnMessagingRead", err)
				}
			}
		}
	})
}

func (s *Server) handlePageSettingsPOSTSave(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}
	var signals struct {
		Username string `json:"username"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "reading signals", err)
		return
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())
	p := app.PageSettings{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	redirect, err := p.POSTSave(r, sse, sess, signals)
	if err != nil {
		s.httpErrIntern(w, r, sse, "handling action PageSettings.POSTSave", err)
		return
	}
	if httpRedirect(w, r, redirect, 0) {
		return
	}
}

func (s *Server) handlePageSettingsPOSTSignOut(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}

	sess, sessToken, ok := s.auth(w, r)
	if !ok {
		s.httpErrUnauth(w)
		return
	}

	closeSession, redirect, err := s.app.POSTSignOut(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageSettings.PostSignOut", err)
		return
	}
	if closeSession {
		if err := s.closeSession(w, r, sessToken); err != nil {
			s.httpErrIntern(w, r, nil, "removing session", err)
			return
		}
	}
	if httpRedirect(w, r, redirect, 0) {
		return
	}
}

func (s *Server) handlePageMessagesGET(w http.ResponseWriter, r *http.Request) {
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}

	q := r.URL.Query()
	var query struct {
		Chat string `query:"chat" reflectsignal:"chatselected"`
	}
	query.Chat = q.Get("chat")

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	body, redirect, enableBackgroundStreaming, err := p.GET(r, sess, query)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageMessages.GET", err)
		return
	}
	if httpRedirect(w, r, redirect, 0) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageMessages", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) {
		if !enableBackgroundStreaming {
			writeBodyAttrOnVisibilityChange(w)
		}

		_, _ = io.WriteString(w, `data-signals:chatselected="'`)
		_, _ = io.WriteString(w, query.Chat)
		_, _ = io.WriteString(w, `'"`)

		if sess.UserID != "" {
			_, _ = io.WriteString(w, `data-init="@get('/messages/_$/'`)
			if enableBackgroundStreaming {
				_, _ = io.WriteString(w, `,{openWhenHidden:true})"`)
			} else {
				_, _ = io.WriteString(w, `)"`)
			}
		}

		_, _ = io.WriteString(w, `data-effect="const params = new URLSearchParams();
			if ($chatselected) params.set('chat', $chatselected);
			const query = params.toString();
			window.history.replaceState(null, '', query ? '/messages?' + query : '/messages');
		"`)
	}

	if err := s.writeHTML(
		w, r, sess, genericHead, nil, body, bodyAttrs,
	); err != nil {
		s.logErr("rendering PageMessages", err)
		return
	}
}

func (s *Server) handlePageMessagesGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, sessToken, ok := s.auth(w, r)
	if !ok {
		return
	}

	if sess.UserID == "" {
		http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
		return
	}

	var signals struct {
		Chat string `json:"chatselected"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "reading signals", err)
		return
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	s.handleStreamRequest(w, r, sessToken, sess, evSubjPageMessages(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.Base.OnMessagingSent(e, sse, sess); err != nil {
					s.logErr("handling PageMessages.Base.OnMessagingSent", err)
				}
				if err := p.OnMessagingSent(e, sse, sess, signals); err != nil {
					s.logErr("handling PageMessages.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingRead):
				var e app.EventMessagingRead
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingRead JSON", err)
					continue
				}
				if err := p.Base.OnMessagingRead(e, sse, sess); err != nil {
					s.logErr("handling PageMessages.Base.OnMessagingSent", err)
				}
				if err := p.OnMessagingRead(e, sse, sess, signals); err != nil {
					s.logErr("handling PageMessages.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingWriting):
				var e app.EventMessagingWriting
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingWriting JSON", err)
					continue
				}
				if err := p.OnMessagingWriting(e, sse, sess); err != nil {
					s.logErr("handling PageMessages.OnMessagingWriting", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingWritingStopped):
				var e app.EventMessagingWritingStopped
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingWritingStopped JSON", err)
					continue
				}
				if err := p.OnMessagingWritingStopped(e, sse, sess); err != nil {
					s.logErr("handling PageMessages.OnMessagingWritingStopped", err)
				}
			}
		}
	})
}

func (s *Server) handlePageMessagesPOSTRead(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}
	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)
	var signals struct {
		ChatSelected string `json:"chatselected"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "reading signals", err)
		return
	}

	q := r.URL.Query()
	var query struct {
		MessageID string `query:"msgid"`
	}
	query.MessageID = q.Get("msgid")

	dispatch := func(
		e1 app.EventMessagingRead,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingRead JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefMessagingRead + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	if err := p.POSTRead(r, sess, query, signals, dispatch); err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageMessages.POSTRead", err)
		return
	}
}

func (s *Server) handlePageMessagesPOSTWriting(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}
	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)
	var signals struct {
		ChatSelected string `json:"chatselected"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "reading signals", err)
		return
	}

	dispatch := func(
		e1 app.EventMessagingWriting,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingWriting JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefMessagingWriting + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	if err := p.POSTWriting(r, sess, signals, dispatch); err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageMessages.POSTWriting", err)
		return
	}
}

func (s *Server) handlePageMessagesPOSTWritingStopped(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}
	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)
	var signals struct {
		ChatSelected string `json:"chatselected"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "reading signals", err)
		return
	}

	dispatch := func(
		e1 app.EventMessagingWritingStopped,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingWritingStopped JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefMessagingWritingStopped + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	if err := p.POSTWritingStopped(r, sess, signals, dispatch); err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageMessages.POSTWritingStopped", err)
		return
	}
}

func (s *Server) handlePageMessagesPOSTSendMessage(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}
	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)
	var signals struct {
		ChatSelected string `json:"chatselected"`
		MessageText  string `json:"messagetext"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "reading signals", err)
		return
	}

	dispatch := func(
		e1 app.EventMessagingWritingStopped,
		e2 app.EventMessagingSent,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingWritingStopped JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefMessagingWritingStopped + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		{
			j, err := json.Marshal(e2)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingSent JSON: %w", err)
			}
			for _, uid := range e2.TargetUserIDs {
				subj := EvSubjPrefMessagingSent + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	p := app.PageMessages{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	if err := p.POSTSendMessage(r, sess, signals, dispatch); err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageMessages.POSTSendMessage", err)
		return
	}
}

func (s *Server) handlePageSearchGET(w http.ResponseWriter, r *http.Request) {
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}

	q := r.URL.Query()
	var query app.SearchParams
	query.Term = q.Get("t")
	query.Category = q.Get("c")
	{
		if q := q.Get("pmin"); q != "" {
			i, err := strconv.ParseInt(q, 10, 64)
			if err != nil {
				s.httpErrBad(w, "unexpected value for query parameter: pmin", err)
				return
			}
			query.PriceMin = i
		}
	}
	{
		if q := q.Get("pmax"); q != "" {
			i, err := strconv.ParseInt(q, 10, 64)
			if err != nil {
				s.httpErrBad(w, "unexpected value for query parameter: pmax", err)
				return
			}
			query.PriceMax = i
		}
	}
	query.Location = q.Get("l")

	p := app.PageSearch{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	body, err := p.GET(r, sess, query)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageSearch.GET", err)
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageSearch", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) {
		writeBodyAttrOnVisibilityChange(w)

		_, _ = io.WriteString(w, `data-signals:term="'`)
		_, _ = io.WriteString(w, query.Term)
		_, _ = io.WriteString(w, `'"`)

		_, _ = io.WriteString(w, `data-signals:category="'`)
		_, _ = io.WriteString(w, query.Category)
		_, _ = io.WriteString(w, `'"`)

		_, _ = io.WriteString(w, `data-signals:pmin="`)
		_, _ = io.WriteString(w, strconv.FormatInt(query.PriceMin, 10))
		_, _ = io.WriteString(w, `"`)

		_, _ = io.WriteString(w, `data-signals:pmax="`)
		_, _ = io.WriteString(w, strconv.FormatInt(query.PriceMax, 10))
		_, _ = io.WriteString(w, `"`)

		_, _ = io.WriteString(w, `data-signals:location="'`)
		_, _ = io.WriteString(w, query.Location)
		_, _ = io.WriteString(w, `'"`)

		if sess.UserID != "" {
			_, _ = io.WriteString(w, `data-init="@get('/search/_$/')"`)
		}

		_, _ = io.WriteString(w, `data-effect="const params = new URLSearchParams();
			if ($term) params.set('t', $term);
			if ($category) params.set('c', $category);
			if ($pmin) params.set('pmin', $pmin);
			if ($pmax) params.set('pmax', $pmax);
			if ($location) params.set('l', $location);
			const query = params.toString();
			window.history.replaceState(null, '', query ? '/search?' + query : '/search');
		"`)
	}

	if err := s.writeHTML(
		w, r, sess, genericHead, nil, body, bodyAttrs,
	); err != nil {
		s.logErr("rendering PageSearch", err)
		return
	}
}

func (s *Server) handlePageSearchGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, sessToken, ok := s.auth(w, r)
	if !ok {
		return
	}

	if sess.UserID == "" {
		http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
		return
	}

	p := app.PageSearch{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	s.handleStreamRequest(w, r, sessToken, sess, evSubjPageSearch(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(e, sse, sess); err != nil {
					s.logErr("handling PageSearch.Base.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingRead):
				var e app.EventMessagingRead
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingRead JSON", err)
					continue
				}
				if err := p.OnMessagingRead(e, sse, sess); err != nil {
					s.logErr("handling PageSearch.Base.OnMessagingRead", err)
				}
			}
		}
	})
}

func (s *Server) handlePageUserGET(w http.ResponseWriter, r *http.Request) {
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}

	var path struct {
		Name string `path:"name"`
	}
	path.Name = r.PathValue("name")

	p := app.PageUser{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	body, head, redirect, err := p.GET(r, sess, path)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageUser.GET", err)
		return
	}
	if httpRedirect(w, r, redirect, 0) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageUser", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) {
		writeBodyAttrOnVisibilityChange(w)
	}

	if err := s.writeHTML(
		w, r, sess, genericHead, head, body, bodyAttrs,
	); err != nil {
		s.logErr("rendering PageUser", err)
		return
	}
}

func (s *Server) handlePageMyPostsGET(w http.ResponseWriter, r *http.Request) {
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}

	p := app.PageMyPosts{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	body, head, redirect, err := p.GET(r, sess)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PageMyPosts.GET", err)
		return
	}
	if httpRedirect(w, r, redirect, 0) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PageMyPosts", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) {
		writeBodyAttrOnVisibilityChange(w)
	}

	if err := s.writeHTML(
		w, r, sess, genericHead, head, body, bodyAttrs,
	); err != nil {
		s.logErr("rendering PageMyPosts", err)
		return
	}
}

func (s *Server) handlePagePostGET(w http.ResponseWriter, r *http.Request) {
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}

	var path struct {
		Slug string `path:"slug"`
	}
	path.Slug = r.PathValue("slug")

	p := app.PagePost{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	body, head, redirect, err := p.GET(r, sess, path)
	if err != nil {
		s.httpErrIntern(w, r, nil, "handling PagePost.GET", err)
		return
	}
	if httpRedirect(w, r, redirect, 0) {
		return
	}
	genericHead, err := s.app.Head(r)
	if err != nil {
		s.httpErrIntern(w, r, nil, "generating generic head for PagePost", err)
		return
	}

	bodyAttrs := func(w http.ResponseWriter) {
		writeBodyAttrOnVisibilityChange(w)

		_, _ = io.WriteString(w, `data-init="@get('/post/`)
		_, _ = io.WriteString(w, path.Slug)
		if sess.UserID != "" {
			_, _ = io.WriteString(w, `/_$/')"`)
		} else {
			_, _ = io.WriteString(w, `/_$/anon/')"`)
		}
	}

	if err := s.writeHTML(
		w, r, sess, genericHead, head, body, bodyAttrs,
	); err != nil {
		s.logErr("rendering PagePost", err)
		return
	}
}

func (s *Server) handlePageSearchPOSTParamChange(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}
	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)
	var signals app.SearchParams
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "reading signals", err)
		return
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())
	p := app.PageSearch{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	if err := p.POSTParamChange(r, sse, sess, signals); err != nil {
		s.httpErrIntern(w, r, sse, "handling action PageSearch.POSTParamChange", err)
		return
	}
}

func (s *Server) handlePagePostGETStream(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, sessToken, ok := s.auth(w, r)
	if !ok {
		return
	}

	if sess.UserID == "" {
		http.Redirect(w, r, r.URL.Path+"/anon", http.StatusSeeOther)
		return
	}

	p := app.PagePost{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	s.handleStreamRequest(w, r, sessToken, sess, evSubjPagePost(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			switch {
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingSent):
				var e app.EventMessagingSent
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingSent JSON", err)
					continue
				}
				if err := p.OnMessagingSent(e, sse, sess); err != nil {
					s.logErr("handling PagePost.Base.OnMessagingSent", err)
				}
			case strings.HasPrefix(msg.Subject, EvSubjPrefMessagingRead):
				var e app.EventMessagingRead
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventMessagingRead JSON", err)
					continue
				}
				if err := p.OnMessagingRead(e, sse, sess); err != nil {
					s.logErr("handling PagePost.Base.OnMessagingRead", err)
				}
			case msg.Subject == EvSubjPostArchived:
				var e app.EventPostArchived
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventPostArchived JSON", err)
					continue
				}
				if err := p.OnPostArchived(e, sse, sess); err != nil {
					s.logErr("handling PagePost.OnPostArchived", err)
				}
			}
		}
	})
}

func (s *Server) handlePagePostGETStreamAnon(w http.ResponseWriter, r *http.Request) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, sessToken, ok := s.auth(w, r)
	if !ok {
		return
	}

	if sess.UserID != "" {
		s.httpErrBad(w, "authenticated client on anonymous stream", nil)
		return
	}

	p := app.PagePost{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	s.handleStreamRequest(w, r, sessToken, sess, evSubjPagePost(sess.UserID), func(
		sse *datastar.ServerSentEventGenerator, ch <-chan Message,
	) {
		for msg := range ch {
			if msg.Subject == EvSubjPostArchived {
				var e app.EventPostArchived
				if err := json.Unmarshal(msg.Data, &e); err != nil {
					s.logErr("unmarshaling EventPostArchived JSON", err)
					continue
				}
				if err := p.OnPostArchived(e, sse, sess); err != nil {
					s.logErr("handling PagePost.OnPostArchived", err)
				}
			}
		}
	})
}

func (s *Server) handlePagePostPOSTSendMessage(
	w http.ResponseWriter, r *http.Request,
) {
	if !s.checkIsDSReq(w, r) {
		return
	}
	sess, _, ok := s.auth(w, r)
	if !ok {
		return
	}
	r.Body = http.MaxBytesReader(w, r.Body, DefaultBodySizeLimit)
	var signals struct {
		MessageText string `json:"messagetext"`
	}
	if err := datastar.ReadSignals(r, &signals); err != nil {
		s.httpErrBad(w, "reading signals", err)
		return
	}

	var path struct {
		Slug string `path:"slug"`
	}
	path.Slug = r.PathValue("slug")

	dispatch := func(
		e1 app.EventMessagingSent,
	) error {
		{
			j, err := json.Marshal(e1)
			if err != nil {
				return fmt.Errorf("marshaling EventMessagingSent JSON: %w", err)
			}
			for _, uid := range e1.TargetUserIDs {
				subj := EvSubjPrefMessagingSent + uid
				err = s.messageBroker.Publish(r.Context(), subj, j)
				if err != nil {
					return fmt.Errorf("publishing subject %q: %w", subj, err)
				}
			}
		}
		return nil
	}

	sse := datastar.NewSSE(w, r, datastar.WithCompression())
	p := app.PagePost{
		App:  s.app,
		Base: app.Base{App: s.app},
	}
	if err := p.POSTSendMessage(r, sse, sess, path, signals, dispatch); err != nil {
		s.httpErrIntern(w, r, nil, "handling action PageMessages.POSTSendMessage", err)
		return
	}
}

func writeBodyAttrOnVisibilityChange(w http.ResponseWriter) {
	_, _ = io.WriteString(w, `data-on:visibilitychange__window=`+
		`"if (!document.hidden) @get(window.location.href)"`)
}
